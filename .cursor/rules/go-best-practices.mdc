---
description: 
globs: 
alwaysApply: false
---
# Go Best Practices

Follow these best practices when writing Go code in this repository. This document is based on analysis of the existing codebase patterns.

## Core Principles

- **Clarity and Simplicity**: Write code that is easy to read, understand, and maintain. Favor explicit over implicit.
- **Dependency Injection**: Use dependency injection to decouple components and enable testing. The functional options pattern is the standard approach.
- **Interface-Driven Design**: Define behavior through interfaces to enable mocking and loose coupling.
- **Explicit Error Handling**: Handle all errors explicitly. Use structured error types for APIs.

## Architecture Patterns

### Functional Options Pattern

Use the functional options pattern for component initialization. This is the standard across controllers and main components:

```go
type ComponentOption func(*Component)

func WithDependency(dep Dependency) ComponentOption {
    return func(c *Component) {
        c.dependency = dep
    }
}

func NewComponent(opts ...ComponentOption) (*Component, error) {
    c := &Component{
        // Set defaults
    }
    
    for _, opt := range opts {
        opt(c)
    }
    
    // Initialize defaults for nil dependencies
    if c.dependency == nil {
        c.dependency = NewDefaultDependency()
    }
    
    return c, nil
}
```

### Interface Design

- **Small, Focused Interfaces**: Keep interfaces small and focused on specific behavior
- **Interface Segregation**: Prefer multiple small interfaces over large ones
- **Testability**: All external dependencies should be behind interfaces for mocking
- **Naming**: Use descriptive names that indicate the behavior (e.g., `InstallationManager`, `NetUtils`)

```go
type NetUtils interface {
    ListValidNetworkInterfaces() ([]string, error)
    DetermineBestNetworkInterface() (string, error)
    FirstValidIPNet(networkInterface string) (*net.IPNet, error)
}
```

## Error Handling

### Structured API Errors

Use structured error types for APIs that need to return detailed error information:

```go
type APIError struct {
    StatusCode int         `json:"status_code,omitempty"`
    Message    string      `json:"message"`
    Field      string      `json:"field,omitempty"`
    Errors     []*APIError `json:"errors,omitempty"`
    err        error       `json:"-"`
}

func (e *APIError) Error() string { /* implementation */ }
func (e *APIError) Unwrap() error { return e.err }
```

### Error Wrapping and Context

- **Wrap Errors**: Always add context when propagating errors using `fmt.Errorf("operation failed: %w", err)`
- **Preserve Original**: Store the original error for unwrapping when using custom error types
- **Meaningful Messages**: Error messages should be actionable and include relevant context

### Error Constructor Functions

Create constructor functions for common error types:

```go
func NewBadRequestError(err error) *APIError {
    return &APIError{
        StatusCode: http.StatusBadRequest,
        Message:    err.Error(),
        err:        err,
    }
}
```

## Naming Conventions

### Package Names
- Use short, concise, all-lowercase names
- Avoid stuttering (don't repeat package name in exported types)
- Examples: `types`, `utils`, `install`, `auth`

### Types and Functions
- **Exported Types**: Use `PascalCase` (e.g., `InstallController`, `APIError`)
- **Exported Functions**: Use `PascalCase` (e.g., `NewInstallController`, `ValidateConfig`)
- **Internal Functions**: Use `camelCase` (e.g., `bindJSON`, `logError`)
- **Variables**: Use `camelCase` for all variables

### Interface Naming
- **Behavior-Based**: Name interfaces after what they do (e.g., `Controller`, `Manager`, `NetUtils`)
- **Avoid Generic Names**: Don't use generic suffixes like `Interface` unless necessary
- **Single Method**: For single-method interfaces, consider the "-er" suffix pattern

## Concurrency and Thread Safety

### Mutex Usage
- Use `sync.RWMutex` for read-heavy workloads
- Keep critical sections small
- Always use defer for unlocking: `defer mu.Unlock()`

### Context Usage
- Pass `context.Context` as the first parameter to functions that may block or need cancellation
- Use `ctx context.Context` as the parameter name
- Don't store contexts in structs; pass them through function calls

## Logging

### Structured Logging with Logrus

- Use `logrus.FieldLogger` interface for dependency injection
- Add contextual fields to log entries for better debugging
- Use appropriate log levels: `Debug`, `Info`, `Warn`, `Error`

```go
logger.WithFields(logrus.Fields{
    "request_id": requestID,
    "user_id":    userID,
}).Info("processing request")
```

### Logging Patterns

- **Error Logging**: Always log errors with context before returning them
- **Request Logging**: Log HTTP requests with relevant fields (method, path, status)
- **Discard Logger**: Use `logger.NewDiscardLogger()` for tests

## JSON and HTTP Handling

### JSON Tags and Serialization

- Use appropriate JSON tags: `json:"field_name,omitempty"`
- Use `json:"-"` for fields that shouldn't be serialized
- Handle both marshaling and unmarshaling in your types

### HTTP Handler Patterns

- Use method receivers on the main API struct: `func (a *API) handlerName(...)`
- Use helper methods for common operations: `bindJSON`, `json`, `jsonError`
- Always validate input and handle errors appropriately

## Testing Support

### Testable Design

- Use interfaces for all external dependencies
- Provide constructor functions that accept test doubles
- Create mock implementations alongside interfaces (e.g., `netutils_mock.go`)

### Test Utilities

- Provide `NewDiscardLogger()` for tests that need a logger
- Use dependency injection to swap real implementations with test doubles
- Create test-specific constructors when needed

## Code Organization

### Package Structure

- **Controllers**: Business logic and orchestration (`controllers/`)
- **Types**: Data structures and domain models (`types/`)
- **Internal**: Implementation details not exposed to other packages (`internal/`)
- **Pkg**: Reusable utilities and helpers (`pkg/`)

### File Organization

- Keep related functionality together in the same file
- Use separate files for tests: `*_test.go`
- Use separate files for mocks: `*_mock.go`
- Keep files focused and reasonably sized (< 500 lines when possible)

## Documentation

### Code Comments

- Document all exported types, functions, and methods
- Use complete sentences in comments
- Explain the "why" not just the "what"
- Include examples for complex APIs

### Swagger/OpenAPI

- Use Swagger annotations for HTTP handlers
- Document request/response structures
- Include error response documentation

## Best Practices Summary

- **Explicit Dependencies**: Use dependency injection with functional options
- **Interface Everything**: Put external dependencies behind interfaces
- **Handle All Errors**: Never ignore errors; wrap them with context
- **Structure for Testing**: Design code to be easily testable
- **Use Standard Libraries**: Prefer standard library over third-party when possible
- **Consistent Patterns**: Follow established patterns in the codebase
- **Clear Separation**: Separate concerns into appropriate packages and layers

