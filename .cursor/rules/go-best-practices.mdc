---
description: 
globs: 
alwaysApply: false
---
# Go Best Practices

Follow these best practices when writing Go code in this repository.

## Core Principles

- **Clarity and Simplicity**: Write code that is easy to read, understand, and maintain. Favor explicit over implicit.
- **Dependency Injection**: Use dependency injection to decouple components and enable testing. The functional options pattern is the standard approach.
- **Interface-Driven Design**: Define behavior through interfaces to enable mocking and loose coupling.
- **Explicit Error Handling**: Handle all errors explicitly. Use structured error types when appropriate.

## Architecture Patterns

### Functional Options Pattern

Use the functional options pattern for component initialization. This is the standard across controllers and main components:

```go
type ComponentOption func(*Component)

func WithDependency(dep Dependency) ComponentOption {
    return func(c *Component) {
        c.dependency = dep
    }
}

func NewComponent(opts ...ComponentOption) (*Component, error) {
    c := &Component{
        // Set defaults
    }
    
    for _, opt := range opts {
        opt(c)
    }
    
    // Initialize defaults for nil dependencies
    if c.dependency == nil {
        c.dependency = NewDefaultDependency()
    }
    
    return c, nil
}
```

### Interface Design

- **Small, Focused Interfaces**: Keep interfaces small and focused on specific behavior
- **Interface Segregation**: Prefer multiple small interfaces over large ones
- **Testability**: All external dependencies should be behind interfaces for mocking
- **Naming**: Use descriptive names that indicate the behavior (e.g., `InstallationManager`, `NetUtils`)

```go
type NetUtils interface {
    ListValidNetworkInterfaces() ([]string, error)
    DetermineBestNetworkInterface() (string, error)
    FirstValidIPNet(networkInterface string) (*net.IPNet, error)
}
```

## Error Handling

### Error Wrapping and Context

- **Wrap Errors**: Always add context when propagating errors using `fmt.Errorf("operation failed: %w", err)`
- **Preserve Original**: Store the original error for unwrapping when using custom error types
- **Meaningful Messages**: Error messages should be actionable and include relevant context

## Naming Conventions

### Package Names
- Use short, concise, all-lowercase names
- Avoid stuttering (don't repeat package name in exported types)
- Examples: `types`, `utils`, `install`, `auth`

### Types and Functions
- **Exported Types**: Use `PascalCase` (e.g., `InstallController`, `NetUtils`)
- **Exported Functions**: Use `PascalCase` (e.g., `NewInstallController`, `ValidateConfig`)
- **Internal Functions**: Use `camelCase` (e.g., `processRequest`, `validateInput`)
- **Variables**: Use `camelCase` for all variables

### Interface Naming
- **Behavior-Based**: Name interfaces after what they do (e.g., `Controller`, `Manager`, `NetUtils`)
- **Avoid Generic Names**: Don't use generic suffixes like `Interface` unless necessary
- **Single Method**: For single-method interfaces, consider the "-er" suffix pattern

## Concurrency and Thread Safety

### Mutex Usage
- Use `sync.RWMutex` for read-heavy workloads
- Keep critical sections small
- Always use defer for unlocking: `defer mu.Unlock()`

### Context Usage
- Pass `context.Context` as the first parameter to functions that may block or need cancellation
- Use `ctx context.Context` as the parameter name
- Don't store contexts in structs; pass them through function calls

## Logging

### Structured Logging with Logrus

- Use `logrus.FieldLogger` interface for dependency injection
- Add contextual fields to log entries for better debugging
- Use appropriate log levels: `Debug`, `Info`, `Warn`, `Error`

```go
logger.WithFields(logrus.Fields{
    "request_id": requestID,
    "user_id":    userID,
}).Info("processing request")
```

### Logging Patterns

- **Error Logging**: Always log errors with context before returning them
- **Discard Logger**: Use `logger.NewDiscardLogger()` for tests
