---
description: 
globs: *.go
alwaysApply: false
---
# Testing

## Testing Philosophy

- **Test for behavior, not implementation**: Tests should verify the public behavior of a unit, not its internal implementation details.
- **Readable and maintainable**: Tests should be easy to read, understand, and maintain. A good test serves as documentation.
- **Fast and reliable**: Tests should run quickly and produce consistent results.

## Test Organization

### Test Types

1. **Unit Tests**: Test individual functions/methods in isolation using mocks for dependencies
2. **Integration Tests**: Test the interaction between multiple components, often with real HTTP requests
3. **API Tests**: Test HTTP endpoints end-to-end with request/response validation

### File Structure

- Unit tests: `*_test.go` files alongside the code they test
- Integration tests: `api/integration/*_test.go` files
- Test assets: Store test data in `assets/` subdirectories within test packages

## Test Structure Patterns

### Table-Driven Tests

Use table-driven tests for testing multiple scenarios. This is the standard pattern across the codebase:

### Test Naming

- Test functions: `TestFunctionName` or `TestTypeName_MethodName`
- Subtest names: Descriptive of the specific scenario being tested
- Use underscores for method tests: `TestAPIError_Error`

## Tooling and Libraries

### Core Libraries

- **Standard testing**: Use the built-in `testing` package
- **Assertions**: Use `github.com/stretchr/testify/assert` and `github.com/stretchr/testify/require`
  - `assert.*`: For non-fatal assertions that continue test execution
  - `require.*`: For fatal assertions that stop test execution on failure
- **Mocks**: Use `github.com/stretchr/testify/mock` for creating mocks

### HTTP Testing

- **Unit-level HTTP testing**: Use `net/http/httptest` for testing individual handlers
- **Integration HTTP testing**: Create full API instances with `httptest.NewServer`
- **API Client testing**: Test both direct HTTP calls and API client wrapper methods

## Testing Patterns by Component Type

### API Handlers

Test HTTP handlers by:
1. Creating mock dependencies
2. Setting up HTTP requests with `httptest.NewRequest`
3. Using `httptest.NewRecorder` to capture responses
4. Validating status codes, headers, and response bodies

### Controllers (Business Logic)

Test controllers by:
1. Mocking all dependencies (managers, utilities, etc.)
2. Setting up mock expectations with `mock.On()` and `mock.InOrder()`
3. Testing both success and error paths
4. Verifying mock expectations with `AssertExpectations(t)`

### Types and Data Structures

Test types by:
1. Validating serialization/deserialization (JSON marshaling)
2. Testing validation methods
3. Testing error handling and edge cases
4. Using table-driven tests for multiple validation scenarios

### Integration Tests

Structure integration tests by:
1. Creating real API instances with test configurations
2. Using `httptest.NewServer` for full HTTP testing
3. Testing authentication flows end-to-end
4. Validating complete request/response cycles
5. Testing with both direct HTTP calls and API client libraries

## Mock Usage

### Mock Setup Patterns

- Use setup functions in table tests: `setupMock func(*MockType)`
- Use `mock.InOrder()` for sequential mock calls
- Use `mock.MatchedBy()` for complex argument matching
- Always call `AssertExpectations(t)` to verify all mocks were called

### Mock Lifecycle

- Create fresh mocks for each test case
- Set up mock expectations before running the test
- Verify mock expectations after the test completes

## Test Structure

### Test Naming
- Use descriptive test names that clearly indicate what is being tested
- Follow the pattern: `TestFunctionName_Scenario_ExpectedResult`
- Example: `TestValidateConfig_EmptyDataDirectory_ReturnsError`

### Use Semantic Naming for Test Cases

- **Name test cases descriptively**: Use meaningful names for test cases rather than generic names like "test case 1"
  ```go
  tests := []struct {
      name           string
      input          *Config
      expectedError  string
  }{
      {
          name:          "empty data directory should return error",
          input:         &Config{DataDirectory: ""},
          expectedError: "data directory cannot be empty",
      },
      {
          name:          "test case 2",
          input:         &Config{DataDirectory: "/opt/data"},
          expectedError: "",
      },
  }
  ```

### Test Organization
- Group related tests in the same file
- Use subtests for variations of the same test case
- Keep test files focused on testing a single component or feature

### Test Coverage and Quality

- **Remove tests that don't call any functions or validate actual behavior**: Tests should assert on real functionality, not just test data structures
  ```go
  func TestValidateConfig_EmptyDirectory_ReturnsError(t *testing.T) {
      config := &Config{DataDirectory: ""}
      err := ValidateConfig(config) // Actually calls the function
      assert.Error(t, err)
  }
  
  func TestConfigStruct_Fields_Exist(t *testing.T) {
      config := &Config{}
      assert.NotNil(t, config) // Just tests data structure
  }
  ```

### Mock Management

- **Extend existing mock interfaces instead of creating new ones**: Reduce maintenance burden by adding methods to existing mocks
  ```go
  // Good - extend existing mock
  type mockInstallController struct {
      GetStatusFunc func() Status
  }
  
  // Bad - create separate mock
  type mockStatusController struct {
      GetStatusFunc func() Status
  }
  ```

