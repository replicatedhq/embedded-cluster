---
description: 
globs: 
alwaysApply: false
---
# API Design Patterns

Follow these established patterns for consistent API design and error handling.

## Error Handling

**Use Typed Errors Instead of String Matching**
- Use `errors.Is()` for error type checking instead of string comparisons
- Define custom error variables for domain-specific errors
- Error handling should be based on error types, not string content
- Someone may change error messaging and unintentionally affect status codes
- Follow established patterns for error type checking in the codebase

**Return Consistent Error Responses**
- Always use `types.APIError` for structured error responses
- Use proper error constructor functions: `NewBadRequestError()`, `NewInternalServerError()`, `NewUnauthorizedError()`, etc.
- Let `jsonError()` helper automatically handle error type conversion
- Use `AppendFieldError()` for validation errors with specific field names

## Handler Structure

**Follow the Standard Handler Pattern**
- Use `bindJSON()` for request parsing with automatic error handling
- Use `json()` for successful responses with proper content-type headers
- Use `jsonError()` for error responses with consistent formatting
- Use `logError()` for structured logging with request context
- Return early on errors - don't continue processing after `bindJSON()` or other errors

**Keep HTTP Layer Separate from Business Logic**
- Handlers should be thin - delegate complex logic to controllers
- Controllers handle business logic and return domain errors
- API layer converts domain errors to HTTP responses using typed errors
- Follow the controller pattern: handlers → controllers → managers → stores

## Dependency Injection & Architecture

**Use the Option Pattern for Constructors**
- All major components use functional options: `NewController(opts ...Option)`
- Options modify struct fields via closures: `func(c *Controller) { c.field = value }`
- Provide default implementations when nil dependencies are detected
- Use dependency injection to enable testing with mocks

**Follow the Layered Architecture**
- **API Layer**: HTTP handlers, routing, middleware
- **Controller Layer**: Business logic orchestration, error handling
- **Manager Layer**: Domain-specific operations, workflow management  
- **Store Layer**: Data persistence, in-memory or disk-based storage

## Authentication & Authorization

**Use Bearer Token Pattern**
- All protected routes use `authMiddleware` on subrouters
- Token extraction follows: `Authorization: Bearer <token>`
- Use typed errors for auth failures: `NewUnauthorizedError()`
- Authentication logic is centralized in auth controller

## Route Organization

**Group Related Routes Using Subrouters**
- Public routes go directly on main router
- Protected routes use `authenticatedRouter` subrouter with middleware
- Domain-specific routes use prefixed subrouters: `/install`, `/console`
- RESTful patterns: GET for retrieval, POST for actions/creation
