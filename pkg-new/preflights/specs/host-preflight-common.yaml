apiVersion: troubleshoot.sh/v1beta2
kind: HostPreflight
metadata:
  name: embedded-cluster-common
spec:
  collectors:
    - memory: {}
    - cpu: {}
    - time: {}
    - ipv4Interfaces: {}
    - kernelModules: {}
    - run:
        collectorName: 'ip-route-table'
        command: 'ip'
        args: ['route']
    # External k0s runtime dependencies
    # https://docs.k0sproject.io/stable/external-runtime-deps/
    - cgroups: {}
    - run:
        collectorName: 'check-proc-filesystem'
        command: 'sh'
        args: ['-c', 'stat -f -c "%T" /proc']
    - run:
        collectorName: 'check-modprobe'
        command: 'sh'
        args: ['-c', 'command -v modprobe']
    - run:
        collectorName: 'check-mount'
        command: 'sh'
        args: ['-c', 'command -v mount']
    - run:
        collectorName: 'check-umount'
        command: 'sh'
        args: ['-c', 'command -v umount']
    - hostOS: {}
    - http:
        collectorName: http-replicated-app
        get:
          url: '{{ .ReplicatedAppURL }}'
          timeout: 5s
          proxy: '{{ .HTTPSProxy }}'
        exclude: '{{ or .IsAirgap (eq .ReplicatedAppURL "") }}'
    - http:
        collectorName: http-proxy-replicated-com
        get:
          url: '{{ .ProxyRegistryURL }}/v2/'
          timeout: 5s
          proxy: '{{ .HTTPSProxy }}'
        exclude: '{{ or .IsAirgap (eq .ProxyRegistryURL "") }}'
    - run:
        collectorName: resolv.conf
        command: 'sh'
        args: ['-c', 'cat /etc/resolv.conf']
    - filesystemPerformance:
        collectorName: filesystem-write-latency-etcd
        timeout: 5m
        directory: {{ .K0sDataDir }}/etcd
        fileSize: 22Mi
        operationSize: 2300
        datasync: true
        runTime: "0" # let it run to completion
    - run:
        collectorName: check-data-dir-symlink
        command: sh
        args:
          - -c
          - |
            [ -d "{{ .DataDir }}" ] && [ -L "{{ .DataDir }}" ] && echo "{{ .DataDir }} is a symlink" || echo "{{ .DataDir }} is not a symlink"
    - dns:
        collectorName: 'wildcard-check'
        hostnames:
          - '*'
    - sysctl: {}
{{- range $index, $element := .TCPConnectionsRequired}}
    - tcpConnect:
        collectorName: 'tcp-connect-{{$index}}'
        address: '{{ $element }}'
        timeout: 30s
{{- end}}
    - run:
        collectorName: 'selinux-mode'
        command: 'sh'
        args: ['-c', 'getenforce || echo "Missing"']
    - run:
        # check execute permissions on the data directory, its parents, and root.
        # this is necessary for executing binaries in the data directory by other users (e.g. etcd).
        collectorName: 'check-data-dir-permissions'
        command: 'sh'
        args:
          - -c
          - |
            dir="{{ .DataDir }}"
            while [ "$dir" != "/" ]; do find "$dir" -maxdepth 0 ! -perm -111; dir=$(dirname "$dir"); done
            find "/" -maxdepth 0 ! -perm -111
    - run:
        collectorName: 'xfs_info-data-dir'
        command: 'sh'
        args:
         - '-c'
         - >
          # Get filesystem type
          fstype=$(findmnt -n -o FSTYPE --target "{{ .DataDir }}")
          if [ "$fstype" = "xfs" ]; then
            echo "Filesystem is XFS. Running xfs_info..."
            xfs_info "{{ .DataDir }}"
          else
            echo "Filesystem is not XFS (detected: $fstype). Skipping xfs_info."
          fi
    - run:
        collectorName: "selinux-labels"
        command: "sh"
        args:
            - -c
            - |
              data_dir="{{ .DataDir }}"
              bin_dir=$data_dir/bin
              # only run our checks if getenforce is available
              if ! $(command -v getenforce); then
                echo "no selinux"
                exit 0
              fi
              # check if selinux is in enforcing mode
              selinux_status=$(getenforce | tr -d '\n')
              if [ "$selinux_status" != "Enforcing" ]; then
                echo "selinux not enforcing"
                exit 0
              fi
              # check user label of data-dir
              data_dir_user_label=$(secon --file $data_dir --user)
              if [ ! "$data_dir_user_label" = "system_u" ]; then
                echo "data_dir_user_label $data_dir_user_label"
              fi
              # check user label of bin dir
              bin_dir_user_label=$(secon --file $bin_dir --user)
              if [ ! "$bin_dir_user_label" = "system_u" ]; then
                echo "bin_dir_user_label $bin_dir_user_label"
              fi
              # check type label of bin dir
              bin_dir_type_label=$(secon --file $bin_dir --type)
              if [ ! "$bin_dir_type_label" = "bin_t" ]; then
                echo "bin_dir_type_label $bin_dir_type_label"
              fi
  analyzers:
    - cpu:
        checkName: CPU
        outcomes:
          - fail:
              when: 'count < 2'
              message: At least 2 CPU cores are required, but fewer are present
          - pass:
              message: At least 2 CPU cores are present
{{- if eq .SystemArchitecture "amd64" }}
    - cpu:
        checkName: CPU Features
        outcomes:
          - pass:
              when: 'supports x86-64-v2'
              message: Host CPU supports x86-64-v2 features
          - fail:
              message: Required x86-64-v2 CPU features are missing. If using a hypervisor, ensure it is configured to expose the necessary CPU features.
{{- end }}
    - memory:
        checkName: Memory
        outcomes:
          - fail:
              when: '< 2G'
              message: At least 2GB of memory is required, but less is present
          - pass:
              message: At least 2GB of memory is present
    - textAnalyze:
        checkName: Default Route
        fileName: host-collectors/run-host/ip-route-table.txt
        regex: 'default'
        outcomes:
          - fail:
              when: 'false'
              message: A default route is required in the main routing table. Add a default route to continue.
          - pass:
              when: 'true'
              message: Default route found in the main routing table
    - ipv4Interfaces:
        checkName: IPv4 Interface
        outcomes:
          - fail:
              when: 'count == 0'
              message: No IPv4 interfaces detected. Add an IPv4 interface to continue.
          - pass:
              when: 'count >= 1'
              message: IPv4 interface detected
    - time:
        checkName: System Clock
        outcomes:
          - fail:
              when: 'ntp == unsynchronized+inactive'
              message: NTP is inactive and the system clock is not synchronized. Enable NTP and synchronize the system clock to continue.
          - fail:
              when: 'ntp == unsynchronized+active'
              message: NTP is enabled but the system clock is not synchronized. Synchronize the system clock to continue.
          - pass:
              when: 'ntp == synchronized+inactive' # don't fail as the system clock might be managed by other protocols (e.g. PTP)
              message: NTP is inactive but the system clock is synchronized
          - pass:
              when: 'ntp == synchronized+active'
              message: NTP is enabled and the system clock is synchronized
          - fail:
              message: 'Unable to determine system clock status'
    - jsonCompare:
        checkName: Cgroups
        fileName: host-collectors/system/cgroups.json
        path: 'cgroup-enabled'
        value: |
          true
        outcomes:
          - fail:
              when: 'false'
              message: cgroup v1 or v2 must be enabled to continue
          - pass:
              when: 'true'
              message: One of cgroup v1 or v2 is enabled
    - jsonCompare:
        checkName: "'cpu' Cgroup Controller"
        fileName: host-collectors/system/cgroups.json
        jsonPath: "{$.allControllers[?(@ == 'cpu')]}"
        value: |
          "cpu"
        outcomes:
          - fail:
              when: 'false'
              message: "'cpu' cgroup controller is not enabled"
          - pass:
              when: 'true'
              message: "'cpu' cgroup controller is enabled"
    - jsonCompare:
        checkName: "'cpuacct' Cgroup Controller"
        fileName: host-collectors/system/cgroups.json
        jsonPath: "{$.allControllers[?(@ == 'cpuacct')]}"
        value: |
          "cpuacct"
        outcomes:
          - fail:
              when: 'false'
              message: "'cpuacct' cgroup controller is not enabled"
          - pass:
              when: 'true'
              message: "'cpuacct' cgroup controller is enabled"
    - jsonCompare:
        checkName: "'cpuset' Cgroup Controller"
        fileName: host-collectors/system/cgroups.json
        jsonPath: "{$.allControllers[?(@ == 'cpuset')]}"
        value: |
          "cpuset"
        outcomes:
          - fail:
              when: 'false'
              message: "'cpuset' cgroup controller is not enabled"
          - pass:
              when: 'true'
              message: "'cpuset' cgroup controller is enabled"
    - jsonCompare:
        checkName: "'memory' Cgroup Controller"
        fileName: host-collectors/system/cgroups.json
        jsonPath: "{$.allControllers[?(@ == 'memory')]}"
        value: |
          "memory"
        outcomes:
          - fail:
              when: 'false'
              message: "'memory' cgroup controller is not enabled"
          - pass:
              when: 'true'
              message: "'memory' cgroup controller is enabled"
    - jsonCompare:
        checkName: "'devices' Cgroup Controller"
        fileName: host-collectors/system/cgroups.json
        jsonPath: "{$.allControllers[?(@ == 'devices')]}"
        value: |
          "devices"
        outcomes:
          - fail:
              when: 'false'
              message: "'devices' cgroup controller is not enabled"
          - pass:
              when: 'true'
              message: "'devices' cgroup controller is enabled"
    - jsonCompare:
        checkName: "'freezer' Cgroup Controller"
        fileName: host-collectors/system/cgroups.json
        jsonPath: "{$.allControllers[?(@ == 'freezer')]}"
        value: |
          "freezer"
        outcomes:
          - fail:
              when: 'false'
              message: "'freezer' cgroup controller is not enabled"
          - pass:
              when: 'true'
              message: "'freezer' cgroup controller is enabled"
    - jsonCompare:
        checkName: "'pids' Cgroup Controller"
        fileName: host-collectors/system/cgroups.json
        jsonPath: "{$.allControllers[?(@ == 'pids')]}"
        value: |
          "pids"
        outcomes:
          - fail:
              when: 'false'
              message: "'pids' cgroup controller is not enabled"
          - pass:
              when: 'true'
              message: "'pids' cgroup controller is enabled"
    - textAnalyze:
        checkName: /proc Filesystem
        fileName: host-collectors/run-host/check-proc-filesystem.txt
        regex: 'proc'
        outcomes:
          - pass:
              when: "true"
              message: /proc filesystem is mounted
          - fail:
              when: "false"
              message: /proc filesystem must be mounted, but it currently is not
    - textAnalyze:
        checkName: "'modprobe' Command"
        fileName: host-collectors/run-host/check-modprobe.txt
        regex: 'modprobe'
        outcomes:
          - pass:
              when: "true"
              message: "'modprobe' command exists in PATH"
          - fail:
              when: "false"
              message: "'modprobe' command must exist in PATH"
    - textAnalyze:
        checkName: "'mount' Command"
        fileName: host-collectors/run-host/check-mount.txt
        regex: 'mount'
        outcomes:
          - pass:
              when: "true"
              message: "'mount' command exists in PATH"
          - fail:
              when: "false"
              message: "'mount' command must exist in PATH"
    - textAnalyze:
        checkName: "'umount' Command"
        fileName: host-collectors/run-host/check-umount.txt
        regex: 'umount'
        outcomes:
          - pass:
              when: "true"
              message: "'umount' command exists in PATH"
          - fail:
              when: "false"
              message: "'umount' command must exist in PATH"
    - hostOS:
        checkName: Kernel Version
        outcomes:
          - pass:
              when: "kernelVersion >= 3.10"
              message: Kernel version is at least 3.10
          - fail:
              message: Kernel version must be at least 3.10
    - http:
        checkName: API Access
        collectorName: http-replicated-app
        exclude: '{{ or .IsAirgap (eq .ReplicatedAppURL "") }}'
        outcomes:
          - fail:
              when: error
              message: >-
                {{ if .IsUI -}}
                Error connecting to {{ .ReplicatedAppURL }}.
                Ensure your firewall is properly configured. If your environment uses a proxy server, go back to the Setup page and specify the proxy settings.
                The static IP addresses for {{ .ReplicatedAppURL }} are 162.159.133.41 and 162.159.134.41.
                {{- else -}}
                Error connecting to {{ .ReplicatedAppURL }}.
                Ensure your firewall is properly configured. If your environment uses a proxy server, use --http-proxy, --https-proxy, and --no-proxy.
                The static IP addresses for {{ .ReplicatedAppURL }} are 162.159.133.41 and 162.159.134.41.
                {{- end }}
          - pass:
              when: 'statusCode == 200'
              message: 'Connected to {{ .ReplicatedAppURL }}'
          - fail:
              message: >-
                {{ if .IsUI -}}
                Unexpected response from {{ .ReplicatedAppURL }}.
                Ensure your firewall is properly configured. If your environment uses a proxy server, go back to the Setup page and specify the proxy settings.
                The static IP addresses for {{ .ReplicatedAppURL }} are 162.159.133.41 and 162.159.134.41.
                {{- else -}}
                Unexpected response from {{ .ReplicatedAppURL }}.
                Ensure your firewall is properly configured. If your environment uses a proxy server, use --http-proxy, --https-proxy, and --no-proxy.
                The static IP addresses for {{ .ReplicatedAppURL }} are 162.159.133.41 and 162.159.134.41.
                {{- end }}
    - http:
        checkName: Proxy Registry Access
        collectorName: http-proxy-replicated-com
        exclude: '{{ or .IsAirgap (eq .ProxyRegistryURL "") }}'
        outcomes:
          - fail:
              when: error
              message: >-
                {{ if .IsUI -}}
                Error connecting to {{ .ProxyRegistryURL }}.
                Ensure your firewall is properly configured. If your environment uses a proxy server, go back to the Setup page and specify the proxy settings.
                The static IP addresses for {{ .ProxyRegistryURL }} are 162.159.137.43 and 162.159.138.43.
                {{- else -}}
                Error connecting to {{ .ProxyRegistryURL }}.
                Ensure your firewall is properly configured, If your environment uses a proxy server, use --http-proxy, --https-proxy, and --no-proxy.
                The static IP addresses for {{ .ProxyRegistryURL }} are 162.159.137.43 and 162.159.138.43.
                {{- end }}
          - pass:
              when: 'statusCode == 401'
              message: 'Connected to {{ .ProxyRegistryURL }}'
          - fail:
              message: >-
                {{ if .IsUI -}}
                Unexpected response from {{ .ProxyRegistryURL }}.
                Ensure your firewall is properly configured. If your environment uses a proxy server, go back to the Setup page and specify the proxy settings.
                The static IP addresses for {{ .ProxyRegistryURL }} are 162.159.137.43 and 162.159.138.43.
                {{- else -}}
                Unexpected response from {{ .ProxyRegistryURL }}.
                Ensure your firewall is properly configured, If your environment uses a proxy server, use --http-proxy, --https-proxy, and --no-proxy.
                The static IP addresses for {{ .ProxyRegistryURL }} are 162.159.137.43 and 162.159.138.43.
                {{- end }}
    - textAnalyze:
        checkName: Resolver Configuration
        fileName: host-collectors/run-host/resolv.conf.txt
        regex: '(?m)^nameserver\s+(localhost|127\.0\.0\.1|::1|::ffff:127\.0\.0\.1)'
        outcomes:
          - fail:
              when: "true"
              message: "Local DNS resolver detected. Remove the localhost, 127.0.0.1, ::1, and/or ::ffff:127.0.0.1 nameserver entries from resolv.conf."
          - pass:
              when: "false"
              message: "No local nameserver entries detected in resolv.conf"
    - textAnalyze:
        checkName: Nameserver Configuration
        fileName: host-collectors/run-host/resolv.conf.txt
        regex: '(?m)^nameserver\s+(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|[0-9a-fA-F]*:[0-9a-fA-F:]+)\s*$'
        outcomes:
          - fail:
              when: "false"
              message: "No nameservers are configured in resolv.conf. Update resolv.conf to include at least one nameserver."
          - pass:
              when: "true"
              message: "Nameservers are configured in resolv.conf."
    - filesystemPerformance:
        checkName: Filesystem Write Latency
        collectorName: filesystem-write-latency-etcd
        outcomes:
          - pass:
              when: "p99 < 10ms"
              message: 'P99 write latency for the disk at {{ .K0sDataDir }}/etcd is {{ "{{" }} .P99 {{ "}}" }}, which is better than the 10 ms requirement.'
          - fail:
              message: 'P99 write latency for the disk at {{ .K0sDataDir }}/etcd is {{ "{{" }} .P99 {{ "}}" }}, but it must be less than 10 ms. A higher-performance disk is required.'
    - textAnalyze:
        checkName: Data Dir Symlink Check
        fileName: host-collectors/run-host/check-data-dir-symlink.txt
        regex: 'is a symlink'
        outcomes:
          - fail:
              when: 'true'
              message: >-
                {{ if .IsUI -}}
                {{ .DataDir }} cannot be symlinked. Remove the symlink, or go back to the Setup page and choose a different data directory.
                {{- else -}}
                {{ .DataDir }} cannot be symlinked. Remove the symlink, or use --data-dir to specify an alternative data directory.
                {{- end }}
          - pass:
              when: 'false'
              message: "{{ .DataDir }} is not a symlink."
    - jsonCompare:
        checkName: Wildcard DNS
        fileName: host-collectors/dns/wildcard-check/result.json
        path: 'resolvedFromSearch'
        value: |
          ""
        outcomes:
          - fail:
              when: 'false'
              message: 'Wildcard DNS entry *.{{ "{{" }}  .resolvedFromSearch {{ "}}" }} detected. Remove the wildcard DNS entry or the {{ "{{" }}  .resolvedFromSearch {{ "}}" }} search domain from resolv.conf.'
          - pass:
              when: 'true'
              message: No wildcard DNS entry detected.
              message: The node IP {{ .NodeIP }} is not within the Global CIDR range {{ .GlobalCIDR.CIDR }}.
    - sysctl:
        checkName: "ARP Filter default value for newly created interfaces"
        outcomes:
          - fail:
              when: 'net.ipv4.conf.default.arp_filter > 0'
              message: "ARP filtering must be disabled by default for newly created interfaces. To disable it, edit /etc/sysctl.conf, add the line 'net.ipv4.conf.default.arp_filter=0', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.conf.default.arp_filter == 0'
              message: "ARP filtering is disabled by default for newly created interfaces."
    - sysctl:
        checkName: "ARP Filter value for all interfaces"
        outcomes:
          - fail:
              when: 'net.ipv4.conf.all.arp_filter > 0'
              message: "ARP filtering must be disabled for all interfaces. To disable it, edit /etc/sysctl.conf, add the line 'net.ipv4.conf.all.arp_filter=0', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.conf.all.arp_filter == 0'
              message: "ARP filtering is disabled for all interfaces."
    - sysctl:
        checkName: "ARP Ignore default value for newly created interfaces"
        outcomes:
          - fail:
              when: 'net.ipv4.conf.default.arp_ignore > 0'
              message: "ARP ignore must be disabled by default for newly created interfaces. To disable it, edit /etc/sysctl.conf, add the line 'net.ipv4.conf.default.arp_ignore=0', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.conf.default.arp_ignore == 0'
              message: "ARP ignore is disabled by default for newly created interfaces."
    - sysctl:
        checkName: "ARP Ignore value for all interfaces"
        outcomes:
          - fail:
              when: 'net.ipv4.conf.all.arp_ignore > 0'
              message: "ARP ignore must be disabled for all interfaces. To disable it, edit /etc/sysctl.conf, add the line 'net.ipv4.conf.all.arp_ignore=0', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.conf.all.arp_ignore == 0'
              message: "ARP ignore is disabled for all interfaces."
    - sysctl:
        checkName: "Reverse Path Filtering default value for newly created interfaces"
        outcomes:
          - fail:
              when: 'net.ipv4.conf.default.rp_filter == 1'
              message: "Reverse path filtering must be set to either loose mode (2 - preferred) or disabled (0) for newly created interfaces. To change it, edit /etc/sysctl.conf, add the line 'net.ipv4.conf.default.rp_filter=2', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.conf.default.rp_filter == 2'
              message: "Reverse path filtering is set to loose mode for newly created interfaces."
          - pass:
              when: 'net.ipv4.conf.default.rp_filter == 0'
              message: "Reverse path filtering is disabled for newly created interfaces."
    - sysctl:
        checkName: "Reverse Path Filtering value for all interfaces"
        outcomes:
          - fail:
              when: 'net.ipv4.conf.all.rp_filter == 1'
              message: "Reverse path filtering must be set to either loose mode (2 - preferred) or disabled (0) for all interfaces. To change it, edit /etc/sysctl.conf, add the line 'net.ipv4.conf.all.rp_filter=2', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.conf.all.rp_filter == 2'
              message: "Reverse path filtering is set to loose mode for all interfaces."
          - pass:
              when: 'net.ipv4.conf.all.rp_filter == 0'
              message: "Reverse path filtering is disabled for all interfaces."
    - sysctl:
        checkName: "IP forwarding"
        outcomes:
          - fail:
              when: 'net.ipv4.ip_forward == 0'
              message: "IP forwarding must be enabled. To enable it, edit /etc/sysctl.conf, add or uncomment the line 'net.ipv4.ip_forward=1', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.ip_forward == 1'
              message: "IP forwarding is enabled."
    - sysctl:
        checkName: "IP forwarding for all interfaces"
        outcomes:
          - fail:
              when: 'net.ipv4.conf.all.forwarding == 0'
              message: "IP forwarding must be enabled for all interfaces. To enable it, edit /etc/sysctl.conf, add or uncomment the line 'net.ipv4.conf.all.forwarding=1', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.conf.all.forwarding == 1'
              message: "IP forwarding is enabled for all interfaces."
    - sysctl:
        checkName: "IP forwarding default value for newly created interfaces"
        outcomes:
          - fail:
              when: 'net.ipv4.conf.default.forwarding == 0'
              message: "IP forwarding must be enabled for newly created interfaces. To enable it, edit /etc/sysctl.conf, add or uncomment the line 'net.ipv4.conf.default.forwarding=1', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.conf.default.forwarding == 1'
              message: "IP forwarding is enabled for newly created interfaces."
    - sysctl:
        checkName: "Bridge netfilter call iptables"
        outcomes:
          - fail:
              when: 'net.bridge.bridge-nf-call-iptables == 0'
              message: "Bridge netfilter call iptables must be enabled. To enable it, edit /etc/sysctl.conf, add or uncomment the line 'net.bridge.bridge-nf-call-iptables=1', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.bridge.bridge-nf-call-iptables == 1'
              message: "Bridge netfilter call iptables is enabled."
    - sysctl:
        checkName: "Maximum number of inotify instances per user"
        outcomes:
          - fail:
              when: "fs.inotify.max_user_instances < 1024"
              message: "The system limit for inotify instances per user must be at least 1024. To increase it, edit /etc/sysctl.conf, add or edit the line 'fs.inotify.max_user_instances=1024', and run 'sudo sysctl -p'."
          - pass:
              message: "The system allows at least 1024 inotify instances per user."
    - sysctl:
        checkName: "Maximum number of inotify watches per user"
        outcomes:
          - fail:
              when: "fs.inotify.max_user_watches < 65536"
              message: "The system limit for inotify watches per user must be at least 65536. To increase it, edit /etc/sysctl.conf, add or edit the line 'fs.inotify.max_user_watches=65536', and run 'sudo sysctl -p'."
          - pass:
              message: "The system allows at least 65536 inotify watches per user."
    - kernelModules:
        checkName: "Overlay kernel module"
        outcomes:
          - pass:
              when: "rosetta == loaded"
              message: The kernel is likely linuxkit, skipping kernel module check
          - pass:
              when: "overlay == loaded,loadable"
              message: The 'overlay' kernel module is loaded or loadable
          - fail:
              when: ""
              message: The 'overlay' kernel module is not loaded or loadable
    - kernelModules:
        checkName: "IP tables kernel module"
        outcomes:
          - pass:
              when: "rosetta == loaded"
              message: The kernel is likely linuxkit, skipping kernel module check
          - pass:
              when: "ip_tables == loaded,loadable"
              message: The 'ip_tables' kernel module is loaded or loadable
          - fail:
              when: ""
              message: The 'ip_tables' kernel module is not loaded or loadable
    - kernelModules:
        checkName: "BR Netfilter kernel module"
        outcomes:
          - pass:
              when: "rosetta == loaded"
              message: The kernel is likely linuxkit, skipping kernel module check
          - pass:
              when: "br_netfilter == loaded,loadable"
              message: The 'br_netfilter' kernel module is loaded or loadable
          - fail:
              when: ""
              message: The 'br_netfilter' kernel module is not loaded or loadable
    - kernelModules:
        checkName: "NF Conntrack kernel module"
        outcomes:
          - pass:
              when: "rosetta == loaded"
              message: The kernel is likely linuxkit, skipping kernel module check
          - pass:
              when: "nf_conntrack == loaded,loadable"
              message: The 'nf_conntrack' kernel module is loaded or loadable
          - fail:
              when: ""
              message: The 'nf_conntrack' kernel module is not loaded or loadable
{{- range $index, $element := .TCPConnectionsRequired}}
    - tcpConnect:
        checkName: "TCP Connection to {{ $element }}"
        collectorName: "tcp-connect-{{$index}}"
        outcomes:
          - fail:
              when: "connection-refused"
              message: "A TCP connection to {{ $element }} is required, but the connection was refused. This can occur, for example, if IP routing is not possible between this host and {{ $element }}, or if your firewall doesn't allow traffic between this host and {{ $element }}."
          - fail:
              when: "connection-timeout"
              message: "A TCP connection to {{ $element }} is required, but the connection timed out. This can occur, for example, if IP routing is not possible between this host and {{ $element }}, or if your firewall doesn't allow traffic between this host and {{ $element }}."
          - fail:
              when: "error"
              message: "A TCP connection to {{ $element }} is required, but an unexpected error occurred. This can occur, for example, if IP routing is not possible between this host and {{ $element }}, or if your firewall doesn't allow traffic between this host and {{ $element }}."
          - pass:
              when: "connected"
              message: "Successful TCP connection to {{ $element }}."
{{- end}}
    - textAnalyze:
        checkName: Data Directory Permissions
        fileName: host-collectors/run-host/check-data-dir-permissions.txt
        regexGroups: '(?ms)(?P<Dirs>.*)'
        outcomes:
          - pass:
              when: "Dirs == ''"
              message: "The data directory ({{ .DataDir }}) and all its parent directories have execute permissions"
          - fail:
              message: >-
                The following directories lack execute permissions: {{ `{{ .Dirs | trim | splitList "\n" | join ", " }}` }}.
    - textAnalyze:
        checkName: Check filesystem on data directory path
        fileName: host-collectors/run-host/xfs_info-data-dir.txt
        regex: 'ftype=0'
        outcomes:
          - fail:
              when: "true"
              message: "The XFS filesystem at {{ .DataDir }} is configured with ftype=0, which is not supported. Reformat the filesystem with ftype=1, or choose a different data directory on a supported filesystem."
          - pass:
              when: "false"
              message: "The filesystem at {{ .DataDir }} is either not XFS or is XFS with ftype=1."
    - textAnalyze:
        checkName: "Selinux data-dir user label"
        fileName: host-collectors/run-host/selinux-labels.txt
        regex: "data_dir_user_label"
        outcomes:
          - fail:
              when: "true"
              message: >-
                  The selinux user context label for {{ .DataDir }} is incorrect. try running: sudo restorecon -RvF {{ .DataDir }}
          - pass:
              when: "false"
    - textAnalyze:
        checkName: "Selinux bin dir user label"
        fileName: host-collectors/run-host/selinux-labels.txt
        regex: "bin_dir_user_label"
        outcomes:
          - fail:
              when: "true"
              message: >-
                  The selinux user context label for {{ .DataDir }}/bin is incorrect. Try running: sudo restorecon -RvF {{ .DataDir }}
          - pass:
              when: "false"
    - textAnalyze:
        checkName: "Selinux bin dir type label"
        fileName: host-collectors/run-host/selinux-labels.txt
        regex: "bin_dir_type_label"
        outcomes:
          - fail:
              when: "true"
              message: >-
                  The selinux type context label for the embedded cluster binary directory are incorrect. Try running: sudo semanage fcontext -a -t bin_t "{{ .DataDir }}/bin(/.*)?" && sudo restorecon -RvF {{ .DataDir }}
          - pass:
              when: "false"
