apiVersion: troubleshoot.sh/v1beta2
kind: HostPreflight
metadata:
  name: ec-cluster-preflight
spec:
  collectors:
    - diskUsage:
        collectorName: root-disk-usage
        path: /
    - diskUsage:
        collectorName: embedded-cluster-path-usage
        path: {{ .DataDir }}
    - memory: {}
    - cpu: {}
    - time: {}
    - ipv4Interfaces: {}
    - kernelModules: {}
    - run:
        collectorName: 'ip-route-table'
        command: 'ip'
        args: ['route']
    # External k0s runtime dependencies
    # https://docs.k0sproject.io/stable/external-runtime-deps/
    - cgroups: {}
    - run:
        collectorName: 'check-proc-filesystem'
        command: 'sh'
        args: ['-c', 'stat -f -c "%T" /proc']
    - run:
        collectorName: 'check-modprobe'
        command: 'sh'
        args: ['-c', 'command -v modprobe']
    - run:
        collectorName: 'check-mount'
        command: 'sh'
        args: ['-c', 'command -v mount']
    - run:
        collectorName: 'check-umount'
        command: 'sh'
        args: ['-c', 'command -v umount']
    - hostOS: {}
    - http:
        collectorName: http-replicated-app
        get:
          url: '{{ .ReplicatedAppURL }}'
          timeout: 5s
          proxy: '{{ .HTTPSProxy }}'
        exclude: '{{ or .IsAirgap (eq .ReplicatedAppURL "") }}'
    - http:
        collectorName: http-proxy-replicated-com
        get:
          url: '{{ .ProxyRegistryURL }}/v2/'
          timeout: 5s
          proxy: '{{ .HTTPSProxy }}'
        exclude: '{{ or .IsAirgap (eq .ProxyRegistryURL "") }}'
    - run:
        collectorName: resolv.conf
        command: 'sh'
        args: ['-c', 'cat /etc/resolv.conf']
    - filesystemPerformance:
        collectorName: filesystem-write-latency-etcd
        timeout: 5m
        directory: {{ .K0sDataDir }}/etcd
        fileSize: 22Mi
        operationSize: 2300
        datasync: true
        runTime: "0" # let it run to completion
    - tcpPortStatus:
        collectorName: ETCD Internal Port
        port: 2379
        interface: lo
    - tcpPortStatus:
        collectorName: ETCD External Port
        port: 2380
    - tcpPortStatus:
        collectorName: Local Artifact Mirror Port
        port: {{ .LocalArtifactMirrorPort }}
        interface: lo
    - tcpPortStatus:
        collectorName: Calico External TCP Port
        port: 9091
    - tcpPortStatus:
        collectorName: Kube API Server Port
        port: 6443
    - tcpPortStatus:
        collectorName: Envoy Internal Port
        port: 7443
        interface: lo
    - tcpPortStatus:
        collectorName: Kotsadm Node Port
        port: {{ .AdminConsolePort }}
    - tcpPortStatus:
        collectorName: Kubelet Port
        port: 10250
    - tcpPortStatus:
        collectorName: K0s API Port
        port: 9443
    - tcpPortStatus:
        collectorName: Calico Node Internal Port
        port: 9099
        interface: lo
    - tcpPortStatus:
        collectorName: Kube Proxy Health Port
        port: 10256
    - tcpPortStatus:
        collectorName: Kube Proxy Metrics Port
        port: 10249
    - tcpPortStatus:
        collectorName: Kube Scheduler Secure Port
        port: 10259
        interface: lo
    - tcpPortStatus:
        collectorName: Kube Controller Secure Port
        port: 10257
        interface: lo
    - tcpPortStatus:
        collectorName: Kubelet Health Port
        port: 10248
        interface: lo
    - udpPortStatus:
        collectorName: Calico Communication Port
        port: 4789
    - run:
        collectorName: check-data-dir-symlink
        command: sh
        args:
          - -c
          - |
            [ -d "{{ .DataDir }}" ] && [ -L "{{ .DataDir }}" ] && echo "{{ .DataDir }} is a symlink" || echo "{{ .DataDir }} is not a symlink"
    - dns:
        collectorName: 'wildcard-check'
        hostnames:
          - '*'
    - subnetAvailable:
        collectorName: Pod CIDR
        exclude: '{{ eq .PodCIDR.CIDR "" }}'
        CIDRRangeAlloc: '{{ .PodCIDR.CIDR }}'
        desiredCIDR: {{.PodCIDR.Size}}
    - subnetAvailable:
        collectorName: Service CIDR
        exclude: '{{ eq .ServiceCIDR.CIDR "" }}'
        CIDRRangeAlloc: '{{ .ServiceCIDR.CIDR }}'
        desiredCIDR: {{.ServiceCIDR.Size}}
    - subnetAvailable:
        collectorName: CIDR
        exclude: '{{ eq .GlobalCIDR.CIDR "" }}'
        CIDRRangeAlloc: '{{ .GlobalCIDR.CIDR }}'
        desiredCIDR: {{.GlobalCIDR.Size}}
    - sysctl: {}
    - networkNamespaceConnectivity:
        collectorName: check-network-namespace-connectivity
        fromCIDR: '{{ .FromCIDR }}'
        toCIDR: '{{ .ToCIDR }}'
{{- range $index, $element := .TCPConnectionsRequired}}
    - tcpConnect:
        collectorName: 'tcp-connect-{{$index}}'
        address: '{{ $element }}'
        timeout: 30s
{{- end}}
    - run:
        collectorName: 'selinux-mode'
        command: 'sh'
        args: ['-c', 'getenforce || echo "Missing"']
    - run:
        # check execute permissions on the data directory, its parents, and root.
        # this is necessary for executing binaries in the data directory by other users (e.g. etcd).
        collectorName: 'check-data-dir-permissions'
        command: 'sh'
        args:
          - -c
          - |
            dir="{{ .DataDir }}"
            while [ "$dir" != "/" ]; do find "$dir" -maxdepth 0 ! -perm -111; dir=$(dirname "$dir"); done
            find "/" -maxdepth 0 ! -perm -111
    - run:
        collectorName: 'xfs_info-data-dir'
        command: 'sh'
        args:
         - '-c'
         - >
          # Get filesystem type
          fstype=$(findmnt -n -o FSTYPE --target "{{ .DataDir }}")
          if [ "$fstype" = "xfs" ]; then
            echo "Filesystem is XFS. Running xfs_info..."
            xfs_info "{{ .DataDir }}"
          else
            echo "Filesystem is not XFS (detected: $fstype). Skipping xfs_info."
          fi
    - run:
        collectorName: "selinux-labels"
        command: "sh"
        args:
            - -c
            - |
              data_dir="{{ .DataDir }}"
              bin_dir=$data_dir/bin
              # only run our checks if getenforce is available
              if ! $(command -v getenforce); then
                echo "no selinux"
                exit 0
              fi
              # check if selinux is in enforcing mode
              selinux_status=$(getenforce | tr -d '\n')
              if [ "$selinux_status" != "Enforcing" ]; then
                echo "selinux not enforcing"
                exit 0
              fi
              # check user label of data-dir
              data_dir_user_label=$(secon --file $data_dir --user)
              if [ ! "$data_dir_user_label" = "system_u" ]; then
                echo "data_dir_user_label $data_dir_user_label"
              fi
              # check user label of bin dir
              bin_dir_user_label=$(secon --file $bin_dir --user)
              if [ ! "$bin_dir_user_label" = "system_u" ]; then
                echo "bin_dir_user_label $bin_dir_user_label"
              fi
              # check type label of bin dir
              bin_dir_type_label=$(secon --file $bin_dir --type)
              if [ ! "$bin_dir_type_label" = "bin_t" ]; then
                echo "bin_dir_type_label $bin_dir_type_label"
              fi
    - run:
        collectorName: "ps-detect-antivirus-and-security-tools"
        command: "sh"
        args:
          - -c
          - |
            pat='(clamav|sophos|esets_daemon|fsav|symantec|mfend|ds_agent|kav|bdagent|s1agent|falcon|illumio|xagt|wdavdaemon|mdatp)'

            if command -v pgrep >/dev/null 2>&1; then
              pgrep -afi "$pat"
            else
              ps -eo args=
            fi \
            | awk -v pat="$pat" '
                BEGIN { IGNORECASE=1 }
                /(awk|grep|pgrep|ps|sh -c)/ { next }
                {
                  line=$0
                  while (match(line, pat)) {
                    print tolower(substr(line, RSTART, RLENGTH))
                    line=substr(line, RSTART+RLENGTH)
                  }
                }
              ' \
            | sort -u
    - systemPackages:
        collectorName: security-tools-packages
        ubuntu:
          - sdcss-kmod
          - sdcss
          - sdcss-scripts
        rhel:
          - sdcss-kmod
          - sdcss
          - sdcss-scripts
  analyzers:
    - cpu:
        checkName: CPU
        outcomes:
          - fail:
              when: 'count < 2'
              message: At least 2 CPU cores are required, but fewer are present
          - pass:
              message: At least 2 CPU cores are present
{{- if eq .SystemArchitecture "amd64" }}
    - cpu:
        checkName: CPU Features
        outcomes:
          - pass:
              when: 'supports x86-64-v2'
              message: Host CPU supports x86-64-v2 features
          - fail:
              message: Required x86-64-v2 CPU features are missing. If using a hypervisor, ensure it is configured to expose the necessary CPU features.
{{- end }}
    - memory:
        checkName: Memory
        outcomes:
          - fail:
              when: '< 2G'
              message: At least 2GB of memory is required, but less is present
          - pass:
              message: At least 2GB of memory is present
    - diskUsage:
        checkName: Embedded Cluster Disk Space
        collectorName: embedded-cluster-path-usage
        outcomes:
          - fail:
              when: 'total < 40Gi'
              message: >-
                {{ if .IsUI -}}
                The filesystem at {{ .DataDir }} has less than 40 Gi of total space. Ensure sufficient space is available, or go back to the Setup page and choose a different data directory.
                {{- else -}}
                The filesystem at {{ .DataDir }} has less than 40 Gi of total space. Ensure sufficient space is available, or use --data-dir to specify an alternative data directory.
                {{- end }}
          - fail:
              when: 'used/total > 80%'
              message: >-
                {{ if .IsUI -}}
                The filesystem at {{ .DataDir }} is more than 80% full. Ensure sufficient space is available, or go back to the Setup page and choose a different data directory.
                {{- else -}}
                The filesystem at {{ .DataDir }} is more than 80% full. Ensure sufficient space is available, or use --data-dir to specify an alternative data directory.
                {{- end }}
          - pass:
              message: The filesystem at {{ .DataDir }} has sufficient space
{{- if ne .ControllerAirgapStorageSpace "" }}
    - diskUsage:
        checkName: Airgap Storage Space
        collectorName: embedded-cluster-path-usage
        outcomes:
          - fail:
              when: 'available < {{ .ControllerAirgapStorageSpace }}'
              message: >-
                {{ if .IsUI -}}
                The filesystem at {{ .DataDir }} has less than {{ .ControllerAirgapStorageSpace }} of available storage space needed to process the air gap bundle.
                Controller nodes require 2x the extracted bundle size for processing.
                Ensure sufficient space is available, or go back to the Setup page and choose a different data directory.
                {{- else -}}
                The filesystem at {{ .DataDir }} has less than {{ .ControllerAirgapStorageSpace }} of available storage space needed to process the air gap bundle.
                Controller nodes require 2x the extracted bundle size for processing.
                Ensure sufficient space is available, or use --data-dir to specify an alternative data directory.
                {{- end }}
          - pass:
              message: The filesystem at {{ .DataDir }} has sufficient available space for airgap bundle processing
{{- end }}
{{- if ne .WorkerAirgapStorageSpace "" }}
    - diskUsage:
        checkName: Worker Airgap Storage Space
        collectorName: embedded-cluster-path-usage
        outcomes:
          - fail:
              when: 'available < {{ .WorkerAirgapStorageSpace }}'
              message: >-
                {{ if .IsUI -}}
                The filesystem at {{ .DataDir }} has less than {{ .WorkerAirgapStorageSpace }} of available storage space needed to store infrastructure images.
                Ensure sufficient space is available, or go back to the Setup page and choose a different data directory.
                {{- else -}}
                The filesystem at {{ .DataDir }} has less than {{ .WorkerAirgapStorageSpace }} of available storage space needed to store infrastructure images.
                Ensure sufficient space is available, or use --data-dir to specify an alternative data directory.
                {{- end }}
          - pass:
              message: The filesystem at {{ .DataDir }} has sufficient available space for worker airgap storage
{{- end }}
    - textAnalyze:
        checkName: Default Route
        fileName: host-collectors/run-host/ip-route-table.txt
        regex: 'default'
        outcomes:
          - fail:
              when: 'false'
              message: A default route is required in the main routing table. Add a default route to continue.
          - pass:
              when: 'true'
              message: Default route found in the main routing table
    - ipv4Interfaces:
        checkName: IPv4 Interface
        outcomes:
          - fail:
              when: 'count == 0'
              message: No IPv4 interfaces detected. Add an IPv4 interface to continue.
          - pass:
              when: 'count >= 1'
              message: IPv4 interface detected
    - time:
        checkName: System Clock
        outcomes:
          - fail:
              when: 'ntp == unsynchronized+inactive'
              message: NTP is inactive and the system clock is not synchronized. Enable NTP and synchronize the system clock to continue.
          - fail:
              when: 'ntp == unsynchronized+active'
              message: NTP is enabled but the system clock is not synchronized. Synchronize the system clock to continue.
          - pass:
              when: 'ntp == synchronized+inactive' # don't fail as the system clock might be managed by other protocols (e.g. PTP)
              message: NTP is inactive but the system clock is synchronized
          - pass:
              when: 'ntp == synchronized+active'
              message: NTP is enabled and the system clock is synchronized
          - fail:
              message: 'Unable to determine system clock status'
    - jsonCompare:
        checkName: Cgroups
        fileName: host-collectors/system/cgroups.json
        path: 'cgroup-enabled'
        value: |
          true
        outcomes:
          - fail:
              when: 'false'
              message: cgroup v1 or v2 must be enabled to continue
          - pass:
              when: 'true'
              message: One of cgroup v1 or v2 is enabled
    - jsonCompare:
        checkName: "'cpu' Cgroup Controller"
        fileName: host-collectors/system/cgroups.json
        jsonPath: "{$.allControllers[?(@ == 'cpu')]}"
        value: |
          "cpu"
        outcomes:
          - fail:
              when: 'false'
              message: "'cpu' cgroup controller is not enabled"
          - pass:
              when: 'true'
              message: "'cpu' cgroup controller is enabled"
    - jsonCompare:
        checkName: "'cpuacct' Cgroup Controller"
        fileName: host-collectors/system/cgroups.json
        jsonPath: "{$.allControllers[?(@ == 'cpuacct')]}"
        value: |
          "cpuacct"
        outcomes:
          - fail:
              when: 'false'
              message: "'cpuacct' cgroup controller is not enabled"
          - pass:
              when: 'true'
              message: "'cpuacct' cgroup controller is enabled"
    - jsonCompare:
        checkName: "'cpuset' Cgroup Controller"
        fileName: host-collectors/system/cgroups.json
        jsonPath: "{$.allControllers[?(@ == 'cpuset')]}"
        value: |
          "cpuset"
        outcomes:
          - fail:
              when: 'false'
              message: "'cpuset' cgroup controller is not enabled"
          - pass:
              when: 'true'
              message: "'cpuset' cgroup controller is enabled"
    - jsonCompare:
        checkName: "'memory' Cgroup Controller"
        fileName: host-collectors/system/cgroups.json
        jsonPath: "{$.allControllers[?(@ == 'memory')]}"
        value: |
          "memory"
        outcomes:
          - fail:
              when: 'false'
              message: "'memory' cgroup controller is not enabled"
          - pass:
              when: 'true'
              message: "'memory' cgroup controller is enabled"
    - jsonCompare:
        checkName: "'devices' Cgroup Controller"
        fileName: host-collectors/system/cgroups.json
        jsonPath: "{$.allControllers[?(@ == 'devices')]}"
        value: |
          "devices"
        outcomes:
          - fail:
              when: 'false'
              message: "'devices' cgroup controller is not enabled"
          - pass:
              when: 'true'
              message: "'devices' cgroup controller is enabled"
    - jsonCompare:
        checkName: "'freezer' Cgroup Controller"
        fileName: host-collectors/system/cgroups.json
        jsonPath: "{$.allControllers[?(@ == 'freezer')]}"
        value: |
          "freezer"
        outcomes:
          - fail:
              when: 'false'
              message: "'freezer' cgroup controller is not enabled"
          - pass:
              when: 'true'
              message: "'freezer' cgroup controller is enabled"
    - jsonCompare:
        checkName: "'pids' Cgroup Controller"
        fileName: host-collectors/system/cgroups.json
        jsonPath: "{$.allControllers[?(@ == 'pids')]}"
        value: |
          "pids"
        outcomes:
          - fail:
              when: 'false'
              message: "'pids' cgroup controller is not enabled"
          - pass:
              when: 'true'
              message: "'pids' cgroup controller is enabled"
    - textAnalyze:
        checkName: /proc Filesystem
        fileName: host-collectors/run-host/check-proc-filesystem.txt
        regex: 'proc'
        outcomes:
          - pass:
              when: "true"
              message: /proc filesystem is mounted
          - fail:
              when: "false"
              message: /proc filesystem must be mounted, but it currently is not
    - textAnalyze:
        checkName: "'modprobe' Command"
        fileName: host-collectors/run-host/check-modprobe.txt
        regex: 'modprobe'
        outcomes:
          - pass:
              when: "true"
              message: "'modprobe' command exists in PATH"
          - fail:
              when: "false"
              message: "'modprobe' command must exist in PATH"
    - textAnalyze:
        checkName: "'mount' Command"
        fileName: host-collectors/run-host/check-mount.txt
        regex: 'mount'
        outcomes:
          - pass:
              when: "true"
              message: "'mount' command exists in PATH"
          - fail:
              when: "false"
              message: "'mount' command must exist in PATH"
    - textAnalyze:
        checkName: "'umount' Command"
        fileName: host-collectors/run-host/check-umount.txt
        regex: 'umount'
        outcomes:
          - pass:
              when: "true"
              message: "'umount' command exists in PATH"
          - fail:
              when: "false"
              message: "'umount' command must exist in PATH"
    - hostOS:
        checkName: Kernel Version
        outcomes:
          - pass:
              when: "kernelVersion >= 3.10"
              message: Kernel version is at least 3.10
          - fail:
              message: Kernel version must be at least 3.10
    - http:
        checkName: API Access
        collectorName: http-replicated-app
        exclude: '{{ or .IsAirgap (eq .ReplicatedAppURL "") }}'
        outcomes:
          - fail:
              when: error
              message: >-
                {{ if .IsUI -}}
                Error connecting to {{ .ReplicatedAppURL }}.
                Ensure your firewall is properly configured. If your environment uses a proxy server, go back to the Setup page and specify the proxy settings.
                The static IP addresses for {{ .ReplicatedAppURL }} are 162.159.133.41 and 162.159.134.41.
                {{- else -}}
                Error connecting to {{ .ReplicatedAppURL }}.
                Ensure your firewall is properly configured. If your environment uses a proxy server, use --http-proxy, --https-proxy, and --no-proxy.
                The static IP addresses for {{ .ReplicatedAppURL }} are 162.159.133.41 and 162.159.134.41.
                {{- end }}
          - pass:
              when: 'statusCode == 200'
              message: 'Connected to {{ .ReplicatedAppURL }}'
          - fail:
              message: >-
                {{ if .IsUI -}}
                Unexpected response from {{ .ReplicatedAppURL }}.
                Ensure your firewall is properly configured. If your environment uses a proxy server, go back to the Setup page and specify the proxy settings.
                The static IP addresses for {{ .ReplicatedAppURL }} are 162.159.133.41 and 162.159.134.41.
                {{- else -}}
                Unexpected response from {{ .ReplicatedAppURL }}.
                Ensure your firewall is properly configured. If your environment uses a proxy server, use --http-proxy, --https-proxy, and --no-proxy.
                The static IP addresses for {{ .ReplicatedAppURL }} are 162.159.133.41 and 162.159.134.41.
                {{- end }}
    - http:
        checkName: Proxy Registry Access
        collectorName: http-proxy-replicated-com
        exclude: '{{ or .IsAirgap (eq .ProxyRegistryURL "") }}'
        outcomes:
          - fail:
              when: error
              message: >-
                {{ if .IsUI -}}
                Error connecting to {{ .ProxyRegistryURL }}.
                Ensure your firewall is properly configured. If your environment uses a proxy server, go back to the Setup page and specify the proxy settings.
                The static IP addresses for {{ .ProxyRegistryURL }} are 162.159.137.43 and 162.159.138.43.
                {{- else -}}
                Error connecting to {{ .ProxyRegistryURL }}.
                Ensure your firewall is properly configured, If your environment uses a proxy server, use --http-proxy, --https-proxy, and --no-proxy.
                The static IP addresses for {{ .ProxyRegistryURL }} are 162.159.137.43 and 162.159.138.43.
                {{- end }}
          - pass:
              when: 'statusCode == 401'
              message: 'Connected to {{ .ProxyRegistryURL }}'
          - fail:
              message: >-
                {{ if .IsUI -}}
                Unexpected response from {{ .ProxyRegistryURL }}.
                Ensure your firewall is properly configured. If your environment uses a proxy server, go back to the Setup page and specify the proxy settings.
                The static IP addresses for {{ .ProxyRegistryURL }} are 162.159.137.43 and 162.159.138.43.
                {{- else -}}
                Unexpected response from {{ .ProxyRegistryURL }}.
                Ensure your firewall is properly configured, If your environment uses a proxy server, use --http-proxy, --https-proxy, and --no-proxy.
                The static IP addresses for {{ .ProxyRegistryURL }} are 162.159.137.43 and 162.159.138.43.
                {{- end }}
    - textAnalyze:
        checkName: Resolver Configuration
        fileName: host-collectors/run-host/resolv.conf.txt
        regex: 'nameserver\s*(localhost|127\.0\.0\.1)'
        outcomes:
          - fail:
              when: "true"
              message: "Local DNS resolver detected. Remove the localhost and/or 127.0.0.1 nameserver entries from resolv.conf."
          - pass:
              when: "false"
              message: "Neither 'nameserver localhost' nor 'nameserver 127.0.01' is present in resolv.conf"
    - textAnalyze:
        checkName: Nameserver Configuration
        fileName: host-collectors/run-host/resolv.conf.txt
        regex: '(?m)^nameserver\s+\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\s*$'
        outcomes:
          - fail:
              when: "false"
              message: "No nameservers are configured in resolv.conf. Update resolv.conf to include at least one nameserver."
          - pass:
              when: "true"
              message: "Nameservers are configured in resolv.conf."
    - filesystemPerformance:
        checkName: Filesystem Write Latency
        collectorName: filesystem-write-latency-etcd
        outcomes:
          - pass:
              when: "p99 < 10ms"
              message: 'P99 write latency for the disk at {{ .K0sDataDir }}/etcd is {{ "{{" }} .P99 {{ "}}" }}, which is better than the 10 ms requirement.'
          - fail:
              message: 'P99 write latency for the disk at {{ .K0sDataDir }}/etcd is {{ "{{" }} .P99 {{ "}}" }}, but it must be less than 10 ms. A higher-performance disk is required.'
    - tcpPortStatus:
        checkName: ETCD Internal Port Availability
        collectorName: ETCD Internal Port
        outcomes:
          - fail:
              when: "connection-refused"
              message: Port 2379/TCP is required, but the connection to it was refused. Ensure port 2379/TCP is available.
          - fail:
              when: "address-in-use"
              message: Port 2379/TCP is required, but another process is already using it. Relocate the conflicting process to continue.
          - fail:
              when: "connection-timeout"
              message: Port 2379/TCP is required, but the connection timed out. Ensure that your firewall doesn't block port 2379/TCP.
          - fail:
              when: "error"
              message: Port 2379/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 2379/TCP is available.
          - pass:
              when: "connected"
              message: Port 2379/TCP is available.
          - error:
              message: Port 2379/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 2379/TCP is available.
    - tcpPortStatus:
        checkName: ETCD External Port Availability
        collectorName: ETCD External Port
        outcomes:
          - fail:
              when: "connection-refused"
              message: Port 2380/TCP is required, but the connection to it was refused. Ensure port 2380/TCP is available.
          - fail:
              when: "address-in-use"
              message: Port 2380/TCP is required, but another process is already using it. Relocate the conflicting process to continue.
          - fail:
              when: "connection-timeout"
              message: "Port 2380/TCP is required, but the connection timed out. Ensure that your firewall doesn't block port 2380/TCP."
          - fail:
              when: "error"
              message: Port 2380/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 2380/TCP is available.
          - pass:
              when: "connected"
              message: Port 2380/TCP is available.
          - error:
              message: Port 2380/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 2380/TCP is available.
    - tcpPortStatus:
        checkName: Local Artifact Mirror Port Availability
        collectorName: Local Artifact Mirror Port
        outcomes:
          - fail:
              when: "connection-refused"
              message: Port {{ .LocalArtifactMirrorPort }}/TCP is required, but the connection to it was refused. Ensure port {{ .LocalArtifactMirrorPort }}/TCP is available.
          - fail:
              when: "address-in-use"
              message: >-
                {{ if .IsUI -}}
                Port {{ .LocalArtifactMirrorPort }}/TCP is required, but another process is already using it. Relocate the conflicting process or go back to the Setup page and choose a different port.
                {{- else -}}
                Port {{ .LocalArtifactMirrorPort }}/TCP is required, but another process is already using it. Relocate the conflicting process or use --local-artifact-mirror-port to select a different port.
                {{- end }}
          - fail:
              when: "connection-timeout"
              message: "Port {{ .LocalArtifactMirrorPort }}/TCP is required, but the connection timed out. Ensure that your firewall doesn't block port {{ .LocalArtifactMirrorPort }}/TCP."
          - fail:
              when: "error"
              message: Port {{ .LocalArtifactMirrorPort }}/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port {{ .LocalArtifactMirrorPort }}/TCP is available.
          - pass:
              when: "connected"
              message: Port {{ .LocalArtifactMirrorPort }}/TCP is available.
          - error:
              message: Port {{ .LocalArtifactMirrorPort }}/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port {{ .LocalArtifactMirrorPort }}/TCP is available.
    - tcpPortStatus:
        checkName: Calico External TCP Port Availability
        collectorName: Calico External TCP Port
        outcomes:
          - fail:
              when: "connection-refused"
              message: Port 9091/TCP is required, but the connection to it was refused. Ensure port 9091/TCP is available.
          - fail:
              when: "address-in-use"
              message: Port 9091/TCP is required, but another process is already using it. Relocate the conflicting process to continue.
          - fail:
              when: "connection-timeout"
              message: "Port 9091/TCP is required, but the connection timed out. Ensure that your firewall doesn't block port 9091/TCP."
          - fail:
              when: "error"
              message: Port 9091/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 9091/TCP is available.
          - pass:
              when: "connected"
              message: Port 9091/TCP is available.
          - error:
              message: Port 9091/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 9091/TCP is available.
    - tcpPortStatus:
        checkName: Kube API Server Port Availability
        collectorName: Kube API Server Port
        outcomes:
          - fail:
              when: "connection-refused"
              message: Port 6443/TCP is required, but the connection to it was refused. Ensure port 6443/TCP is available.
          - fail:
              when: "address-in-use"
              message: Port 6443/TCP is required, but another process is already using it. Relocate the conflicting process to continue.
          - fail:
              when: "connection-timeout"
              message: "Port 6443/TCP is required, but the connection timed out. Ensure that your firewall doesn't block port 6443/TCP."
          - fail:
              when: "error"
              message: Port 6443/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 6443/TCP is available.
          - pass:
              when: "connected"
              message: Port 6443/TCP is available.
          - error:
              message: Port 6443/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 6443/TCP is available.
    - tcpPortStatus:
        checkName: Envoy Internal Port Availability
        collectorName: Envoy Internal Port
        outcomes:
          - fail:
              when: "connection-refused"
              message: Port 7443/TCP is required, but the connection to it was refused. Ensure port 7443/TCP is available.
          - fail:
              when: "address-in-use"
              message: Port 7443/TCP is required, but another process is already using it. Relocate the conflicting process to continue.
          - fail:
              when: "connection-timeout"
              message: "Port 7443/TCP is required, but the connection timed out. Ensure that your firewall doesn't block port 7443/TCP."
          - fail:
              when: "error"
              message: Port 7443/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 7443/TCP is available.
          - pass:
              when: "connected"
              message: Port 7443/TCP is available.
          - error:
              message: Port 7443/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 7443/TCP is available.
    - tcpPortStatus:
        checkName: Kotsadm Node Port Availability
        collectorName: Kotsadm Node Port
        outcomes:
          - fail:
              when: "connection-refused"
              message: Port {{ .AdminConsolePort }}/TCP is required, but the connection to it was refused. Ensure port {{ .AdminConsolePort }}/TCP is available.
          - fail:
              when: "address-in-use"
              message: >-
                {{ if .IsUI -}}
                Port {{ .AdminConsolePort }}/TCP is required, but another process is already using it. Relocate the conflicting process or go back to the Setup page and choose a different port.
                {{- else -}}
                Port {{ .AdminConsolePort }}/TCP is required, but another process is already using it. Relocate the conflicting process or use --admin-console-port to select a different port.
                {{- end }}
          - fail:
              when: "connection-timeout"
              message: "Port {{ .AdminConsolePort }}/TCP is required, but the connection timed out. Ensure that your firewall doesn't block port {{ .AdminConsolePort }}/TCP."
          - fail:
              when: "error"
              message: Port {{ .AdminConsolePort }}/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port {{ .AdminConsolePort }}/TCP is available.
          - pass:
              when: "connected"
              message: Port {{ .AdminConsolePort }}/TCP is available.
          - error:
              message: Port {{ .AdminConsolePort }}/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port {{ .AdminConsolePort }}/TCP is available.
    - tcpPortStatus:
        checkName: Kubelet Port Availability
        collectorName: Kubelet Port
        outcomes:
          - fail:
              when: "connection-refused"
              message: Port 10250/TCP is required, but the connection to it was refused. Ensure port 10250/TCP is available.
          - fail:
              when: "address-in-use"
              message: Port 10250/TCP is required, but another process is already using it. Relocate the conflicting process to continue.
          - fail:
              when: "connection-timeout"
              message: "Port 10250/TCP is required, but the connection timed out. Ensure that your firewall doesn't block port 10250/TCP."
          - fail:
              when: "error"
              message: Port 10250/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 10250/TCP is available.
          - pass:
              when: "connected"
              message: Port 10250/TCP is available.
          - error:
              message: Port 10250/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 10250/TCP is available.
    - tcpPortStatus:
        checkName: K0s API Port Availability
        collectorName: K0s API Port
        outcomes:
          - fail:
              when: "connection-refused"
              message: Port 9443/TCP is required, but the connection to it was refused. Ensure port 9443/TCP is available.
          - fail:
              when: "address-in-use"
              message: Port 9443/TCP is required, but another process is already using it. Relocate the conflicting process to continue.
          - fail:
              when: "connection-timeout"
              message: "Port 9443/TCP is required, but the connection timed out. Ensure that your firewall doesn't block port 9443/TCP."
          - fail:
              when: "error"
              message: Port 9443/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 9443/TCP is available.
          - pass:
              when: "connected"
              message: Port 9443/TCP is available.
          - error:
              message: Port 9443/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 9443/TCP is available.
    - tcpPortStatus:
        checkName: Calico Node Internal Port Availability
        collectorName: Calico Node Internal Port
        outcomes:
          - fail:
              when: "connection-refused"
              message: Port 9099/TCP is required, but the connection to it was refused. Ensure port 9099/TCP is available.
          - fail:
              when: "address-in-use"
              message: Port 9099/TCP is required, but another process is already using it. Relocate the conflicting process to continue.
          - fail:
              when: "connection-timeout"
              message: "Port 9099/TCP is required, but the connection timed out. Ensure that your firewall doesn't block port 9099/TCP."
          - fail:
              when: "error"
              message: Port 9099/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 9099/TCP is available.
          - pass:
              when: "connected"
              message: Port 9099/TCP is available.
          - error:
              message: Port 9099/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 9099/TCP is available.
    - tcpPortStatus:
        checkName: Kube Proxy Health Port Availability
        collectorName: Kube Proxy Health Port
        outcomes:
          - fail:
              when: "connection-refused"
              message: Port 10256/TCP is required, but the connection to it was refused. Ensure port 10256/TCP is available.
          - fail:
              when: "address-in-use"
              message: Port 10256/TCP is required, but another process is already using it. Relocate the conflicting process to continue.
          - fail:
              when: "connection-timeout"
              message: "Port 10256/TCP is required, but the connection timed out. Ensure that your firewall doesn't block port 10256/TCP."
          - fail:
              when: "error"
              message: Port 10256/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 10256/TCP is available.
          - pass:
              when: "connected"
              message: Port 10256/TCP is available.
          - error:
              message: Port 10256/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 10256/TCP is available.
    - tcpPortStatus:
        checkName: Kube Proxy Metrics Port Availability
        collectorName: Kube Proxy Metrics Port
        outcomes:
          - fail:
              when: "connection-refused"
              message: Port 10249/TCP is required, but the connection to it was refused. Ensure port 10249/TCP is available.
          - fail:
              when: "address-in-use"
              message: Port 10249/TCP is required, but another process is already using it. Relocate the conflicting process to continue.
          - fail:
              when: "connection-timeout"
              message: "Port 10249/TCP is required, but the connection timed out. Ensure that your firewall doesn't block port 10249/TCP."
          - fail:
              when: "error"
              message: Port 10249/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 10249/TCP is available.
          - pass:
              when: "connected"
              message: Port 10249/TCP is available.
          - error:
              message: Port 10249/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 10249/TCP is available.
    - tcpPortStatus:
        checkName: Kube Scheduler Secure Port Availability
        collectorName: Kube Scheduler Secure Port
        outcomes:
          - fail:
              when: "connection-refused"
              message: Port 10259/TCP is required, but the connection to it was refused. Ensure port 10259/TCP is available.
          - fail:
              when: "address-in-use"
              message: Port 10259/TCP is required, but another process is already using it. Relocate the conflicting process to continue.
          - fail:
              when: "connection-timeout"
              message: "Port 10259/TCP is required, but the connection timed out. Ensure that your firewall doesn't block port 10259/TCP."
          - fail:
              when: "error"
              message: Port 10259/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 10259/TCP is available.
          - pass:
              when: "connected"
              message: Port 10259/TCP is available.
          - error:
              message: Port 10259/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 10259/TCP is available.
    - tcpPortStatus:
        checkName: Kube Controller Secure Port Availability
        collectorName: Kube Controller Secure Port
        outcomes:
          - fail:
              when: "connection-refused"
              message: Port 10257/TCP is required, but the connection to it was refused. Ensure port 10257/TCP is available.
          - fail:
              when: "address-in-use"
              message: Port 10257/TCP is required, but another process is already using it. Relocate the conflicting process to continue.
          - fail:
              when: "connection-timeout"
              message: "Port 10257/TCP is required, but the connection timed out. Ensure that your firewall doesn't block port 10257/TCP."
          - fail:
              when: "error"
              message: Port 10257/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 10257/TCP is available.
          - pass:
              when: "connected"
              message: Port 10257/TCP is available.
          - error:
              message: Port 10257/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 10257/TCP is available.
    - tcpPortStatus:
        checkName: Kubelet Health Port Availability
        collectorName: Kubelet Health Port
        outcomes:
          - fail:
              when: "connection-refused"
              message: Port 10248/TCP is required, but the connection to it was refused. Ensure port 10248/TCP is available.
          - fail:
              when: "address-in-use"
              message: Port 10248/TCP is required, but another process is already using it. Relocate the conflicting process to continue.
          - fail:
              when: "connection-timeout"
              message: "Port 10248/TCP is required, but the connection timed out. Ensure that your firewall doesn't block port 10248/TCP."
          - fail:
              when: "error"
              message: Port 10248/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 10248/TCP is available.
          - pass:
              when: "connected"
              message: Port 10248/TCP is available.
          - error:
              message: Port 10248/TCP is required, but an unexpected error occurred when trying to connect to it. Ensure port 10248/TCP is available.
    - udpPortStatus:
        checkName: Calico Communication Port Availability
        collectorName: Calico Communication Port
        outcomes:
          - fail:
              when: "connection-refused"
              message: Port 4789/UDP is required, but the connection to it was refused. Ensure port 4789/UDPTCP is available.
          - fail:
              when: "address-in-use"
              message: Port 4789/UDP is required, but another process is already using it. Relocate the conflicting process to continue.
          - fail:
              when: "connection-timeout"
              message: Port 4789/UDP is required, but the connection timed out. Ensure that your firewall doesn't block port 4789/UDP.
          - fail:
              when: "error"
              message: Port 4789/UDP is required, but an unexpected error occurred when trying to connect to it. Ensure port 4789/UDP is available.
          - pass:
              when: "connected"
              message: Port 4789/UDP is available.
          - error:
              message: Port 4789/UDP is required, but an unexpected error occurred when trying to connect to it. Ensure port 4789/UDP is available.
    - textAnalyze:
        checkName: Data Dir Symlink Check
        fileName: host-collectors/run-host/check-data-dir-symlink.txt
        regex: 'is a symlink'
        outcomes:
          - fail:
              when: 'true'
              message: >-
                {{ if .IsUI -}}
                {{ .DataDir }} cannot be symlinked. Remove the symlink, or go back to the Setup page and choose a different data directory.
                {{- else -}}
                {{ .DataDir }} cannot be symlinked. Remove the symlink, or use --data-dir to specify an alternative data directory.
                {{- end }}
          - pass:
              when: 'false'
              message: "{{ .DataDir }} is not a symlink."
    - jsonCompare:
        checkName: Wildcard DNS
        fileName: host-collectors/dns/wildcard-check/result.json
        path: 'resolvedFromSearch'
        value: |
          ""
        outcomes:
          - fail:
              when: 'false'
              message: 'Wildcard DNS entry *.{{ "{{" }}  .resolvedFromSearch {{ "}}" }} detected. Remove the wildcard DNS entry or the {{ "{{" }}  .resolvedFromSearch {{ "}}" }} search domain from resolv.conf.'
          - pass:
              when: 'true'
              message: No wildcard DNS entry detected.
    - subnetAvailable:
        checkName: Pod CIDR Availability
        collectorName: Pod CIDR
        exclude: '{{ eq .PodCIDR.CIDR "" }}'
        outcomes:
          - fail:
              when: "no-subnet-available"
              message: >-
                The network range {{ .PodCIDR.CIDR }} is not available. Use --pod-cidr to specify an available CIDR block.
          - pass:
              when: "a-subnet-is-available"
              message: Specified Pod CIDR is available.
    - subnetAvailable:
        checkName: Service CIDR Availability
        collectorName: Service CIDR
        exclude: '{{ eq .ServiceCIDR.CIDR "" }}'
        outcomes:
          - fail:
              when: "no-subnet-available"
              message: >-
                The network range {{ .ServiceCIDR.CIDR }} is not available. Use --service-cidr to specify an available CIDR block.
          - pass:
              when: "a-subnet-is-available"
              message: Specified Service CIDR is available.
    - subnetAvailable:
        checkName: CIDR Availability
        collectorName: CIDR
        exclude: '{{ eq .GlobalCIDR.CIDR "" }}'
        outcomes:
          - fail:
              when: "no-subnet-available"
              message: >-
                {{ if .IsUI -}}
                The network range {{ .GlobalCIDR.CIDR }} is not available. Go back to the Setup page and choose a different reserved network range of available private IP addresses (/16 or larger).
                {{- else -}}
                The network range {{ .GlobalCIDR.CIDR }} is not available. Use --cidr to specify a CIDR block of available private IP addresses (/16 or larger).
                {{- end }}
          - pass:
              when: "a-subnet-is-available"
              message: Specified CIDR is available.
    - subnetContainsIP:
        checkName: Node IP in Pod CIDR Check
        cidr: '{{ .PodCIDR.CIDR }}'
        ip: '{{ .NodeIP }}'
        exclude: '{{ eq .PodCIDR.CIDR "" }}'
        outcomes:
          - fail:
              when: "true"
              message: >-
                {{ if .IsJoin -}}
                The node IP {{ .NodeIP }} cannot be within the Pod CIDR range {{ .PodCIDR.CIDR }}. Use --network-interface to specify a different network interface.
                {{- else -}}
                The node IP {{ .NodeIP }} cannot be within the Pod CIDR range {{ .PodCIDR.CIDR }}. Use --pod-cidr to specify a different Pod CIDR, or use --network-interface to specify a different network interface.
                {{- end }}
          - pass:
              when: "false"
              message: The node IP {{ .NodeIP }} is not within the Pod CIDR range {{ .PodCIDR.CIDR }}.
    - subnetContainsIP:
        checkName: Node IP in Service CIDR Check
        cidr: '{{ .ServiceCIDR.CIDR }}'
        ip: '{{ .NodeIP }}'
        exclude: '{{ eq .ServiceCIDR.CIDR "" }}'
        outcomes:
          - fail:
              when: "true"
              message: >-
                {{ if .IsJoin -}}
                The node IP {{ .NodeIP }} cannot be within the Service CIDR range {{ .ServiceCIDR.CIDR }}. Use --network-interface to specify a different network interface.
                {{- else -}}
                The node IP {{ .NodeIP }} cannot be within the Service CIDR range {{ .ServiceCIDR.CIDR }}. Use --service-cidr to specify a different Service CIDR, or use --network-interface to specify a different network interface.
                {{- end }}
          - pass:
              when: "false"
              message: The node IP {{ .NodeIP }} is not within the Service CIDR range {{ .ServiceCIDR.CIDR }}.
    - subnetContainsIP:
        checkName: Node IP in Global CIDR Check
        cidr: '{{ .GlobalCIDR.CIDR }}'
        ip: '{{ .NodeIP }}'
        exclude: '{{ eq .GlobalCIDR.CIDR "" }}'
        outcomes:
          - fail:
              when: "true"
              message: >-
                {{ if .IsJoin -}}
                {{ if .IsUI -}}
                The node IP {{ .NodeIP }} cannot be within the reserved network range ({{ .GlobalCIDR.CIDR }}). Go back to the Setup page and choose a different network interface.
                {{- else -}}
                The node IP {{ .NodeIP }} cannot be within the CIDR block ({{ .GlobalCIDR.CIDR }}). Use --network-interface to specify a different network interface.
                {{- end }}
                {{- else -}}
                {{ if .IsUI -}}
                The node IP {{ .NodeIP }} cannot be within the reserved network range ({{ .GlobalCIDR.CIDR }}). Go back to the Setup page and choose a different reserved network range of available private IP addresses (/16 or larger) or specify a different network interface.
                {{- else -}}
                The node IP {{ .NodeIP }} cannot be within the CIDR block ({{ .GlobalCIDR.CIDR }}). Use --cidr to specify a different CIDR block of available private IP addresses (/16 or larger), or use --network-interface to specify a different network interface.
                {{- end }}
                {{- end }}
          - pass:
              when: "false"
              message: The node IP {{ .NodeIP }} is not within the Global CIDR range {{ .GlobalCIDR.CIDR }}.
    - sysctl:
        checkName: "ARP Filter default value for newly created interfaces"
        outcomes:
          - fail:
              when: 'net.ipv4.conf.default.arp_filter > 0'
              message: "ARP filtering must be disabled by default for newly created interfaces. To disable it, edit /etc/sysctl.conf, add the line 'net.ipv4.conf.default.arp_filter=0', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.conf.default.arp_filter == 0'
              message: "ARP filtering is disabled by default for newly created interfaces."
    - sysctl:
        checkName: "ARP Filter value for all interfaces"
        outcomes:
          - fail:
              when: 'net.ipv4.conf.all.arp_filter > 0'
              message: "ARP filtering must be disabled for all interfaces. To disable it, edit /etc/sysctl.conf, add the line 'net.ipv4.conf.all.arp_filter=0', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.conf.all.arp_filter == 0'
              message: "ARP filtering is disabled for all interfaces."
    - sysctl:
        checkName: "ARP Ignore default value for newly created interfaces"
        outcomes:
          - fail:
              when: 'net.ipv4.conf.default.arp_ignore > 0'
              message: "ARP ignore must be disabled by default for newly created interfaces. To disable it, edit /etc/sysctl.conf, add the line 'net.ipv4.conf.default.arp_ignore=0', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.conf.default.arp_ignore == 0'
              message: "ARP ignore is disabled by default for newly created interfaces."
    - sysctl:
        checkName: "ARP Ignore value for all interfaces"
        outcomes:
          - fail:
              when: 'net.ipv4.conf.all.arp_ignore > 0'
              message: "ARP ignore must be disabled for all interfaces. To disable it, edit /etc/sysctl.conf, add the line 'net.ipv4.conf.all.arp_ignore=0', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.conf.all.arp_ignore == 0'
              message: "ARP ignore is disabled for all interfaces."
    - sysctl:
        checkName: "Reverse Path Filtering default value for newly created interfaces"
        outcomes:
          - fail:
              when: 'net.ipv4.conf.default.rp_filter == 1'
              message: "Reverse path filtering must be set to either loose mode (2 - preferred) or disabled (0) for newly created interfaces. To change it, edit /etc/sysctl.conf, add the line 'net.ipv4.conf.default.rp_filter=2', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.conf.default.rp_filter == 2'
              message: "Reverse path filtering is set to loose mode for newly created interfaces."
          - pass:
              when: 'net.ipv4.conf.default.rp_filter == 0'
              message: "Reverse path filtering is disabled for newly created interfaces."
    - sysctl:
        checkName: "Reverse Path Filtering value for all interfaces"
        outcomes:
          - fail:
              when: 'net.ipv4.conf.all.rp_filter == 1'
              message: "Reverse path filtering must be set to either loose mode (2 - preferred) or disabled (0) for all interfaces. To change it, edit /etc/sysctl.conf, add the line 'net.ipv4.conf.all.rp_filter=2', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.conf.all.rp_filter == 2'
              message: "Reverse path filtering is set to loose mode for all interfaces."
          - pass:
              when: 'net.ipv4.conf.all.rp_filter == 0'
              message: "Reverse path filtering is disabled for all interfaces."
    - sysctl:
        checkName: "IP forwarding"
        outcomes:
          - fail:
              when: 'net.ipv4.ip_forward == 0'
              message: "IP forwarding must be enabled. To enable it, edit /etc/sysctl.conf, add or uncomment the line 'net.ipv4.ip_forward=1', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.ip_forward == 1'
              message: "IP forwarding is enabled."
    - sysctl:
        checkName: "IP forwarding for all interfaces"
        outcomes:
          - fail:
              when: 'net.ipv4.conf.all.forwarding == 0'
              message: "IP forwarding must be enabled for all interfaces. To enable it, edit /etc/sysctl.conf, add or uncomment the line 'net.ipv4.conf.all.forwarding=1', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.conf.all.forwarding == 1'
              message: "IP forwarding is enabled for all interfaces."
    - sysctl:
        checkName: "IP forwarding default value for newly created interfaces"
        outcomes:
          - fail:
              when: 'net.ipv4.conf.default.forwarding == 0'
              message: "IP forwarding must be enabled for newly created interfaces. To enable it, edit /etc/sysctl.conf, add or uncomment the line 'net.ipv4.conf.default.forwarding=1', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.ipv4.conf.default.forwarding == 1'
              message: "IP forwarding is enabled for newly created interfaces."
    - sysctl:
        checkName: "Bridge netfilter call iptables"
        outcomes:
          - fail:
              when: 'net.bridge.bridge-nf-call-iptables == 0'
              message: "Bridge netfilter call iptables must be enabled. To enable it, edit /etc/sysctl.conf, add or uncomment the line 'net.bridge.bridge-nf-call-iptables=1', and run 'sudo sysctl -p'."
          - pass:
              when: 'net.bridge.bridge-nf-call-iptables == 1'
              message: "Bridge netfilter call iptables is enabled."
    - sysctl:
        checkName: "Maximum number of inotify instances per user"
        outcomes:
          - fail:
              when: "fs.inotify.max_user_instances < 1024"
              message: "The system limit for inotify instances per user must be at least 1024. To increase it, edit /etc/sysctl.conf, add or edit the line 'fs.inotify.max_user_instances=1024', and run 'sudo sysctl -p'."
          - pass:
              message: "The system allows at least 1024 inotify instances per user."
    - sysctl:
        checkName: "Maximum number of inotify watches per user"
        outcomes:
          - fail:
              when: "fs.inotify.max_user_watches < 65536"
              message: "The system limit for inotify watches per user must be at least 65536. To increase it, edit /etc/sysctl.conf, add or edit the line 'fs.inotify.max_user_watches=65536', and run 'sudo sysctl -p'."
          - pass:
              message: "The system allows at least 65536 inotify watches per user."
    - kernelModules:
        checkName: "Overlay kernel module"
        outcomes:
          - pass:
              when: "rosetta == loaded"
              message: The kernel is likely linuxkit, skipping kernel module check
          - pass:
              when: "overlay == loaded,loadable"
              message: The 'overlay' kernel module is loaded or loadable
          - fail:
              when: ""
              message: The 'overlay' kernel module is not loaded or loadable
    - kernelModules:
        checkName: "IP tables kernel module"
        outcomes:
          - pass:
              when: "rosetta == loaded"
              message: The kernel is likely linuxkit, skipping kernel module check
          - pass:
              when: "ip_tables == loaded,loadable"
              message: The 'ip_tables' kernel module is loaded or loadable
          - fail:
              when: ""
              message: The 'ip_tables' kernel module is not loaded or loadable
    - kernelModules:
        checkName: "BR Netfilter kernel module"
        outcomes:
          - pass:
              when: "rosetta == loaded"
              message: The kernel is likely linuxkit, skipping kernel module check
          - pass:
              when: "br_netfilter == loaded,loadable"
              message: The 'br_netfilter' kernel module is loaded or loadable
          - fail:
              when: ""
              message: The 'br_netfilter' kernel module is not loaded or loadable
    - kernelModules:
        checkName: "NF Conntrack kernel module"
        outcomes:
          - pass:
              when: "rosetta == loaded"
              message: The kernel is likely linuxkit, skipping kernel module check
          - pass:
              when: "nf_conntrack == loaded,loadable"
              message: The 'nf_conntrack' kernel module is loaded or loadable
          - fail:
              when: ""
              message: The 'nf_conntrack' kernel module is not loaded or loadable
    - networkNamespaceConnectivity:
        collectorName: check-network-namespace-connectivity
        outcomes:
        - pass:
            message: Communication between {{ "{{ .FromCIDR }}" }} and {{ "{{ .ToCIDR }}" }} is working
        - fail:
            message: Network communication between the pods network CIDR {{ "{{ .FromCIDR }}" }} and the services network CIDR {{ "{{ .ToCIDR }}" }} is currently disrupted on this node. This issue may prevent pods from properly interacting with services. To resolve this, please review and adjust the firewall configuration on this node to ensure it allows traffic between these network CIDRs.
{{- range $index, $element := .TCPConnectionsRequired}}
    - tcpConnect:
        checkName: "TCP Connection to {{ $element }}"
        collectorName: "tcp-connect-{{$index}}"
        outcomes:
          - fail:
              when: "connection-refused"
              message: "A TCP connection to {{ $element }} is required, but the connection was refused. This can occur, for example, if IP routing is not possible between this host and {{ $element }}, or if your firewall doesn't allow traffic between this host and {{ $element }}."
          - fail:
              when: "connection-timeout"
              message: "A TCP connection to {{ $element }} is required, but the connection timed out. This can occur, for example, if IP routing is not possible between this host and {{ $element }}, or if your firewall doesn't allow traffic between this host and {{ $element }}."
          - fail:
              when: "error"
              message: "A TCP connection to {{ $element }} is required, but an unexpected error occurred. This can occur, for example, if IP routing is not possible between this host and {{ $element }}, or if your firewall doesn't allow traffic between this host and {{ $element }}."
          - pass:
              when: "connected"
              message: "Successful TCP connection to {{ $element }}."
{{- end}}
    - textAnalyze:
        checkName: Data Directory Permissions
        fileName: host-collectors/run-host/check-data-dir-permissions.txt
        regexGroups: '(?ms)(?P<Dirs>.*)'
        outcomes:
          - pass:
              when: "Dirs == ''"
              message: "The data directory ({{ .DataDir }}) and all its parent directories have execute permissions"
          - fail:
              message: >-
                The following directories lack execute permissions: {{ `{{ .Dirs | trim | splitList "\n" | join ", " }}` }}.
    - textAnalyze:
        checkName: Check filesystem on data directory path
        fileName: host-collectors/run-host/xfs_info-data-dir.txt
        regex: 'ftype=0'
        outcomes:
          - fail:
              when: "true"
              message: "The XFS filesystem at {{ .DataDir }} is configured with ftype=0, which is not supported. Reformat the filesystem with ftype=1, or choose a different data directory on a supported filesystem."
          - pass:
              when: "false"
              message: "The filesystem at {{ .DataDir }} is either not XFS or is XFS with ftype=1."
    - textAnalyze:
        checkName: "Selinux data-dir user label"
        fileName: host-collectors/run-host/selinux-labels.txt
        regex: "data_dir_user_label"
        outcomes:
          - fail:
              when: "true"
              message: >-
                  The selinux user context label for {{ .DataDir }} is incorrect. try running: sudo restorecon -RvF {{ .DataDir }}
          - pass:
              when: "false"
    - textAnalyze:
        checkName: "Selinux bin dir user label"
        fileName: host-collectors/run-host/selinux-labels.txt
        regex: "bin_dir_user_label"
        outcomes:
          - fail:
              when: "true"
              message: >-
                  The selinux user context label for {{ .DataDir }}/bin is incorrect. Try running: sudo restorecon -RvF {{ .DataDir }}
          - pass:
              when: "false"
    - textAnalyze:
        checkName: "Selinux bin dir type label"
        fileName: host-collectors/run-host/selinux-labels.txt
        regex: "bin_dir_type_label"
        outcomes:
          - fail:
              when: "true"
              message: >-
                  The selinux type context label for the embedded cluster binary directory are incorrect. Try running: sudo semanage fcontext -a -t bin_t "{{ .DataDir }}/bin(/.*)?" && sudo restorecon -RvF {{ .DataDir }}
          - pass:
              when: "false"
    - textAnalyze:
        checkName: "Detect Threat Management and Network Security Tools"
        fileName: host-collectors/run-host/ps-detect-antivirus-and-security-tools.txt
        regexGroups: '(?ms)(?P<Detected>.*)'
        ignoreIfNoFiles: true
        outcomes:
          - pass:
              when: "Detected == ''"
              message: "No antivirus or network security tools detected."
          - warn:
              message: |-
                The following antivirus or network security tools were detected:
                {{ "{{" }} .Detected {{ "}}" }}

                These types of tools have been known to interfere with Kubernetes operation in various ways. If you experience an installation problem, you may need to disable these tools temporarily as part of the troubleshooting process to identify if any system administrator exceptions may be required to maintain necessary internal Kubernetes operations.
    - systemPackages:
        checkName: "Detected Security Packages"
        collectorName: security-tools-packages
        outcomes:
          - warn:
              when: '{{ "{{" }} .IsInstalled {{ "}}" }}'
              message: Package {{ "{{" }} .Name {{ "}}" }} is installed. This tool can interfere with kubernetes operation. Ensure the tool is either disabled or configured to not interfere with kubernetes operation.
          - pass:
              message: Package {{ "{{" }} .Name {{ "}}" }} is not installed
