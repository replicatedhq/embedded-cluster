package release

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	kotsv1beta1 "github.com/replicatedhq/kotskinds/apis/kots/v1beta1"
	"gopkg.in/yaml.v3"
)

const metadataPreface = `#
# this file is automatically generated by buildtools. manual edits are not recommended.
# to regenerate this file, run the following commands:
#
# $ make buildtools
# $ output/bin/buildtools update addon <addon name>
#
`
const valuesPreface = `#
# this file is automatically generated by the buildtools utility. Manual edits to this file
# are not recommended and may be overwritten. to regenerate this file, please execute the
# following commands:
#
# $ make buildtools
# $ output/bin/buildtools update addon <addon name>
#
# should you need to modify any configurations or settings within this file, please update
# the values.tpl.yaml file located in the same directory. after making the necessary changes,
# regenerate this file using the aforementioned commands to ensure all modifications are
# correctly applied.
#
`

type AddonMetadata struct {
	Version       string                `yaml:"version"`
	Location      string                `yaml:"location"`
	Images        map[string]AddonImage `yaml:"images"`
	ReplaceImages bool                  `yaml:"-"`
}

type AddonImage struct {
	Repo string `yaml:"repo"`
	Tag  string `yaml:"tag"`
}

func (i AddonImage) String() string {
	if strings.HasPrefix(i.Tag, "latest@") {
		// The image appears in containerd images without the "latest" tag and causes an
		// ImagePullBackOff error
		return fmt.Sprintf("%s@%s", i.Repo, strings.TrimPrefix(i.Tag, "latest@"))
	}
	return fmt.Sprintf("%s:%s", i.Repo, i.Tag)
}

var funcMap = template.FuncMap{
	"TrimPrefix": func(prefix, s string) string {
		return strings.TrimPrefix(s, prefix)
	},
	"ImageString": func(i AddonImage) string {
		return i.String()
	},
}

func GetValuesWithOriginalImages(addon string) (map[string]interface{}, error) {
	tplpath := filepath.Join("pkg", "addons", addon, "static", "values.tpl.yaml")
	tpl, err := os.ReadFile(tplpath)
	if err != nil {
		return nil, fmt.Errorf("failed to read values template: %w", err)
	}
	tmpl, err := template.New(fmt.Sprintf("builder-%s", addon)).Funcs(funcMap).Parse(string(tpl))
	if err != nil {
		return nil, fmt.Errorf("failed to parse values template: %w", err)
	}
	buf := bytes.NewBufferString(valuesPreface)
	if err := tmpl.Execute(buf, AddonMetadata{}); err != nil {
		return nil, fmt.Errorf("failed to execute values template: %w", err)
	}
	var values map[string]interface{}
	if err := yaml.Unmarshal(buf.Bytes(), &values); err != nil {
		return nil, fmt.Errorf("failed to unmarshal values: %w", err)
	}
	return values, nil
}

func (a *AddonMetadata) Save(addon string) error {
	buf := bytes.NewBufferString(metadataPreface)
	if err := yaml.NewEncoder(buf).Encode(a); err != nil {
		return fmt.Errorf("failed to encode addon metadata: %w", err)
	}

	fpath := filepath.Join("pkg", "addons", addon, "static", "metadata.yaml")
	if err := os.WriteFile(fpath, buf.Bytes(), 0600); err != nil {
		return fmt.Errorf("failed to write addon metadata: %w", err)
	}

	return a.RenderValues(addon, "values.tpl.yaml", "values.yaml")
}

func (a *AddonMetadata) RenderValues(addon, tplfile, dest string) error {
	tplpath := filepath.Join("pkg", "addons", addon, "static", tplfile)
	tpl, err := os.ReadFile(tplpath)
	if err != nil {
		return fmt.Errorf("failed to read values template: %w", err)
	}

	tmpl, err := template.New(addon).Funcs(funcMap).Parse(string(tpl))
	if err != nil {
		return fmt.Errorf("failed to parse values template: %w", err)
	}

	buf := bytes.NewBufferString(valuesPreface)
	if err := tmpl.Execute(buf, a); err != nil {
		return fmt.Errorf("failed to execute values template: %w", err)
	}

	valuespath := filepath.Join("pkg", "addons", addon, "static", dest)
	if err := os.WriteFile(valuespath, buf.Bytes(), 0600); err != nil {
		return fmt.Errorf("failed to write values.yaml: %w", err)
	}

	return nil
}

func ParseAddonMetadata(rawmetadata string, license *kotsv1beta1.License) (*AddonMetadata, error) {
	templated, err := Template(rawmetadata, license)
	if err != nil {
		return nil, fmt.Errorf("template metadata: %w", err)
	}
	var parsed AddonMetadata
	if err := yaml.Unmarshal([]byte(templated), &parsed); err != nil {
		return nil, fmt.Errorf("unmarshal metadata: %w", err)
	}
	return &parsed, nil
}

func ParseAddonHelmValues(rawvalues string, license *kotsv1beta1.License) (map[string]interface{}, error) {
	templated, err := Template(rawvalues, license)
	if err != nil {
		return nil, fmt.Errorf("template helm values: %w", err)
	}
	parsed := make(map[string]interface{})
	if err := yaml.Unmarshal([]byte(templated), &parsed); err != nil {
		return nil, fmt.Errorf("unmarshal helm values: %w", err)
	}
	return parsed, nil
}
