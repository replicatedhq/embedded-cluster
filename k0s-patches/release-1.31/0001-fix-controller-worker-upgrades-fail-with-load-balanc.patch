From 99879e26b2aa7515b5072dc8a059ad374725c74c Mon Sep 17 00:00:00 2001
From: Ethan Mosbaugh <ethan@replicated.com>
Date: Tue, 23 Sep 2025 10:19:35 -0700
Subject: [PATCH] fix: controller worker upgrades fail with load balancer

---
 cmd/worker/worker.go          |  18 +++++-
 pkg/component/worker/utils.go | 108 ++++++++++++++++++++++++++++++++++
 2 files changed, 125 insertions(+), 1 deletion(-)

diff --git a/cmd/worker/worker.go b/cmd/worker/worker.go
index 778f8a11f..0989577d4 100644
--- a/cmd/worker/worker.go
+++ b/cmd/worker/worker.go
@@ -119,6 +119,18 @@ func (c *Command) Start(ctx context.Context) error {
 
 	componentManager := manager.New(prober.DefaultProber)
 
+	// When upgrading controller+worker nodes in a multi-node cluster with a load balancer, the API
+	// server address needs to be overridden to point to the local API server. This is needed so
+	// that the kubelet will not connect to an API server that is running a previous version of
+	// k0s which would violate the Kubernetes version skew policy.
+	if controller != nil {
+		directKubeconfigPath, err := worker.CreateDirectKubeletKubeconfig(ctx, c.K0sVars, nodeName)
+		if err != nil {
+			return fmt.Errorf("failed to create direct kubelet kubeconfig: %w", err)
+		}
+		kubeletKubeconfigPath = directKubeconfigPath
+	}
+
 	var staticPods worker.StaticPods
 
 	if workerConfig.NodeLocalLoadBalancing.IsEnabled() {
@@ -131,7 +143,11 @@ func (c *Command) Start(ctx context.Context) error {
 		if err != nil {
 			return fmt.Errorf("failed to create node-local load balancer reconciler: %w", err)
 		}
-		kubeletKubeconfigPath = reconciler.GetKubeletKubeconfigPath()
+		// If this is a worker only node, the kubelet should use the NLLB kubelet kubeconfig path
+		// rather than the direct kubelet kubeconfig path in the controller+worker mode.
+		if controller == nil {
+			kubeletKubeconfigPath = reconciler.GetKubeletKubeconfigPath()
+		}
 		staticPods = sp
 
 		componentManager.Add(ctx, sp)
diff --git a/pkg/component/worker/utils.go b/pkg/component/worker/utils.go
index 5830e2195..e89a7d8d9 100644
--- a/pkg/component/worker/utils.go
+++ b/pkg/component/worker/utils.go
@@ -21,10 +21,13 @@ import (
 	"errors"
 	"fmt"
 	"io/fs"
+	"net"
+	"net/url"
 	"os"
 	"path"
 	"path/filepath"
 	"runtime"
+	"strconv"
 	"time"
 
 	"github.com/k0sproject/k0s/internal/pkg/dir"
@@ -219,3 +222,108 @@ func writeKubeletBootstrapKubeconfig(kubeconfig []byte) (string, error) {
 
 	return bootstrapFile.Name(), nil
 }
+
+// CreateDirectKubeletKubeconfig creates a kubelet kubeconfig that points directly to the local API
+// server instead of using NLLB. This is used on controller+worker nodes where we want kubelet to
+// connect directly to the local API server.
+func CreateDirectKubeletKubeconfig(ctx context.Context, k0sVars *config.CfgVars, nodeName apitypes.NodeName) (string, error) {
+	log := logrus.WithFields(logrus.Fields{"component": "bootstrap-kubelet", "node_name": nodeName})
+
+	nodeConfig, err := k0sVars.NodeConfig()
+	if err != nil {
+		return "", fmt.Errorf("failed to load node config: %w", err)
+	}
+
+	apiSpec := nodeConfig.Spec.API
+
+	// Determine the local API server address
+	var localAPIServer string
+	if apiSpec.OnlyBindToAddress {
+		// API server binds only to specific address, use that address with proper IPv6 bracketing
+		localAPIServer = net.JoinHostPort(apiSpec.Address, strconv.Itoa(apiSpec.Port))
+	} else {
+		// API server binds to all interfaces, use localhost
+		// Try to resolve localhost to get the appropriate loopback address (IPv4/IPv6)
+		loopbackIP, err := getLoopbackIP(ctx)
+		if err != nil {
+			log.WithError(err).Warn("Failed to resolve localhost, falling back to 127.0.0.1")
+			loopbackIP = net.IPv4(127, 0, 0, 1)
+		}
+		localAPIServer = net.JoinHostPort(loopbackIP.String(), strconv.Itoa(apiSpec.Port))
+	}
+
+	log.Debugf("Using direct local API server URL for kubelet: %s", localAPIServer)
+
+	directKubeconfig, err := readKubeconfig(k0sVars.KubeletAuthConfigPath)
+	if err != nil {
+		return "", fmt.Errorf("failed to read kubeconfig: %w", err)
+	}
+
+	directKubeconfigPath := filepath.Join(k0sVars.RunDir, "kubelet-direct.conf")
+
+	if err := writePatchedKubeconfig(directKubeconfigPath, directKubeconfig, localAPIServer); err != nil {
+		return "", fmt.Errorf("failed to write load-balanced kubeconfig file: %w", err)
+	}
+
+	log.Debugf("Wrote direct kubeconfig file: %s", directKubeconfigPath)
+	return directKubeconfigPath, nil
+}
+
+// readKubeconfig reads a kubeconfig file and returns a clientcmdapi.Config
+func readKubeconfig(path string) (*clientcmdapi.Config, error) {
+	kubeconfig, err := clientcmd.LoadFromFile(path)
+	if err != nil {
+		return nil, err
+	}
+
+	// Resolve non-absolute paths in case the kubeconfig gets written to another folder.
+	err = clientcmd.ResolveLocalPaths(kubeconfig)
+	if err != nil {
+		return nil, err
+	}
+
+	if err := clientcmdapi.MinifyConfig(kubeconfig); err != nil {
+		return nil, err
+	}
+
+	return kubeconfig, err
+}
+
+// writePatchedKubeconfig writes a kubeconfig file with the given server address
+func writePatchedKubeconfig(path string, kubeconfig *clientcmdapi.Config, server string) error {
+	kubeconfig = kubeconfig.DeepCopy()
+	if err := clientcmdapi.MinifyConfig(kubeconfig); err != nil {
+		return err
+	}
+
+	cluster := kubeconfig.Clusters[kubeconfig.Contexts[kubeconfig.CurrentContext].Cluster]
+	clusterServer, err := url.Parse(cluster.Server)
+	if err != nil {
+		return fmt.Errorf("invalid server: %w", err)
+	}
+	clusterServer.Host = server
+	cluster.Server = clusterServer.String()
+
+	bytes, err := clientcmd.Write(*kubeconfig)
+	if err != nil {
+		return err
+	}
+
+	return file.WriteContentAtomically(path, bytes, constant.CertSecureMode)
+}
+
+// getLoopbackIP resolves localhost to get the appropriate loopback IP address (IPv4 or IPv6)
+func getLoopbackIP(ctx context.Context) (net.IP, error) {
+	localIPs, err := net.DefaultResolver.LookupIPAddr(ctx, "localhost")
+	if err != nil {
+		return nil, fmt.Errorf("failed to resolve localhost: %w", err)
+	}
+
+	for _, addr := range localIPs {
+		if addr.IP.IsLoopback() {
+			return addr.IP, nil
+		}
+	}
+
+	return nil, fmt.Errorf("no loopback IPs found for localhost: %v", localIPs)
+}
-- 
2.46.1

